{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-ipcoal","title":"Welcome to ipcoal","text":"<p>ipcoal is a package for simulating and analyzing genealogies and  sequences across genomes, with a focus on phylogenetic-scale analyses.  ipcoal builds upon the powerful coalescent simulator msprime, but provides a different syntax and workflow for describing and visualizing complex  demographic models (e.g., divergence times, effective population sizes, migration events), calling simulation functions, and summarizing or analyzing results.  ipcoal includes many methods for downstream analysis of coalescent simulations, such as calculating likelihoods under the Kingman coalescent, multispecies  coalescent, and sequentially Markov coalescent models, as well as implementing phylogenetic inference software on simulated sequences.</p> <p>The ipcoal package is designed for use in jupyter-notebooks to encourage  reproducible and shareable results. It is a powerful tool for posterior  predictive data analysis, methods validation, for generating training data for machine learning, and as a teaching tool for learning the coalescent process  in an interactive and visual environment.</p>"},{"location":"#our-goals","title":"Our goals","text":"<ul> <li>Accessible: Easy to install and easy to use, with documentation and cookbooks.</li> <li>Reproducible: Designed for interactive use in Jupyter notebooks.</li> <li>Reliable: Tested on each build.</li> <li>Comprehensible: We provide simple methods to verify and visualize models.</li> <li>Didactic: We provide exercises for teaching in a classroom.</li> <li>Transparent: Read our code and make it your own.</li> </ul>"},{"location":"#contact-us","title":"Contact us","text":"<ul> <li>Questions or Feature requests? Raise a ticket at the GitHub repo.</li> </ul>"},{"location":"FAQs/","title":"Frequently Asked Questions","text":""},{"location":"FAQs/#how-do-i-get-help","title":"How do I get help?","text":"<p>The first place to look for help or answers is in here in the documentation. You can use the search bar in the navigation to search for terms or function names. The next place is in the source documentation strings. Some of the  source code is available here in the docs, but the rest can be accessed in an interactive environment (e.g., jupyter) by executing a function name followed by one or two question marks. The docstrings often contain detailed descriptions of parameters and example usage. Finally, you can seek further help or advice by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"help wanted\" or \"question\" as the category for your issue.</p>"},{"location":"FAQs/#how-do-i-report-bug","title":"How do I report bug?","text":"<p>If you believe you have encountered a bug in toytree please let us know by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"bug\".</p>"},{"location":"FAQs/#how-can-i-request-a-new-feature","title":"How can I request a new feature","text":"<p>We are happy to implement new useful methods in toytree that will help to  grow its userbase. To request the implementation of a new method please do so by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"enhancement\". </p>"},{"location":"FAQs/#how-can-i-contribute-to-toytree","title":"How can I contribute to toytree","text":"<p>We welcome contributors! If you are interested in contributing to toytree please first read our contributor's guide. This describes a shared framework and style to ensure a cohesive coding style throughout the source code. Then, you can raise an Issue on GitHub to indicate the project you are working on. This way, you can find if others are already working on the method, or find additional contributors for help. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"enhancement\", and under Assignees, assign your self.</p>"},{"location":"MSC_likelihood/","title":"MSC likelihood","text":"In\u00a0[1]: Copied! <pre>import ipcoal\n</pre> import ipcoal In\u00a0[2]: Copied! <pre># get 100 unlinked genealogies (G) embedded in a species tree (S)\nS, G, I = ipcoal.msc.get_test_data(nloci=100, nsites=1, seed=123)\n\n# get likelihood of G | S\nipcoal.msc.get_msc_loglik(S, G, I)\n</pre> # get 100 unlinked genealogies (G) embedded in a species tree (S) S, G, I = ipcoal.msc.get_test_data(nloci=100, nsites=1, seed=123)  # get likelihood of G | S ipcoal.msc.get_msc_loglik(S, G, I) Out[2]: <pre>7973.467153781378</pre> In\u00a0[3]: Copied! <pre># get (S, G, I) for an example dataset\nS, G, I = ipcoal.msc.get_test_data(nloci=100, nsites=1, seed=123)\n</pre> # get (S, G, I) for an example dataset S, G, I = ipcoal.msc.get_test_data(nloci=100, nsites=1, seed=123) In\u00a0[4]: Copied! <pre># draw the first genealogy embedded\nipcoal.draw.draw_embedded_genealogy(S, G[0], I);\n</pre> # draw the first genealogy embedded ipcoal.draw.draw_embedded_genealogy(S, G[0], I); idx=5 Ne=1e+05 Tc=1 Tg=2e+05idx=3 Ne=1e+05 Tc=3 Tg=6e+05idx=4 Ne=1e+05 Tc=1 Tg=2e+05idx=2 Ne=1e+05 Tc=2 Tg=4e+05idx=0 Ne=1e+05 Tc=1 Tg=2e+05idx=1 Ne=1e+05 Tc=1 Tg=2e+05idx=6 Ne=1e+05 Tc=0 Tg=0A_0A_2A_1B_0B_1C_0D_0node=0node=1node=2node=7node=3node=4node=8node=5node=6node=9node=10node=11node=120250000500000750000 <p>In this case, the species tree contains all of the information to describe a demographic model. This includes the topology for lineages A, B, C, and D, their divergence times, and an effective population size parameter for each species tree interval. These data are stored in the ToyTree object as node data.</p> In\u00a0[5]: Copied! <pre># show the species tree data\nS.get_node_data([\"idx\", \"name\", \"height\", \"Ne\"])\n</pre> # show the species tree data S.get_node_data([\"idx\", \"name\", \"height\", \"Ne\"]) Out[5]: idx name height Ne 0 0 A 0.0 100000 1 1 B 0.0 100000 2 2 C 0.0 100000 3 3 D 0.0 100000 4 4 200000.0 100000 5 5 400000.0 100000 6 6 600000.0 100000 <p>The genealogy embedding table contains the information of how a genealogy fits into a species tree container. Our goal is to calculate the likelihood of observing this genealogy given the species tree parameters. Thus, we need to calculate the probability of coalescence at each unit of time. Fortunately, this problem is simplified by recognizing that these probabilities are constant within some intervals of time. In other words, the probability of coalescent is piece-wise constant. Knowing this, we can separate out these intervals where it is constant and compute the probabilities just within each one.</p> <p>The probability of coalescence is calculated following the Kingman coalscent for k samples as $\\frac{k(k - 1)}{4N}$. This is a product of the rate of coalescence given the effective population size in that interval $\\frac{1}{2N}$, and the combinatorial number of ways that 2 samples could have coalesced given k samples in that interval $\\frac{k(k-1)}{2}$. Thus, the probability of a coalescence event is greater when k is larger, and when $N_e$ is smaller.</p> In\u00a0[6]: Copied! <pre># get embedding table for the first genealogy\nipcoal.msc.get_genealogy_embedding_table(S, G[0], I)\n</pre> # get embedding table for the first genealogy ipcoal.msc.get_genealogy_embedding_table(S, G[0], I) Out[6]: start stop st_node neff nedges dist gidx edges 0 0.000000 8.348442e+04 0 100000.0 3 8.348442e+04 0 [0, 1, 2] 1 83484.416529 2.000000e+05 0 100000.0 2 1.165156e+05 0 [2, 7] 2 0.000000 6.205383e+04 1 100000.0 2 6.205383e+04 0 [3, 4] 3 62053.832461 2.000000e+05 1 100000.0 1 1.379462e+05 0 [8] 4 0.000000 4.000000e+05 2 100000.0 1 4.000000e+05 0 [5] 5 0.000000 6.000000e+05 3 100000.0 1 6.000000e+05 0 [6] 6 200000.000000 2.838717e+05 4 100000.0 3 8.387172e+04 0 [2, 7, 8] 7 283871.722216 4.000000e+05 4 100000.0 2 1.161283e+05 0 [7, 9] 8 400000.000000 4.257337e+05 5 100000.0 3 2.573368e+04 0 [5, 7, 9] 9 425733.683785 6.000000e+05 5 100000.0 2 1.742663e+05 0 [5, 10] 10 600000.000000 7.091705e+05 6 100000.0 3 1.091705e+05 0 [5, 6, 10] 11 709170.541694 7.423249e+05 6 100000.0 2 3.315435e+04 0 [10, 11] 12 742324.888479 inf 6 100000.0 1 inf 0 [12] <p>Each interval of the table delimits a gene tree node (coalescence) or species tree node (interval breakpoint). Each lists its <code>start</code> and <code>stop</code> time (in generations), the species tree node ID (<code>st_node</code>), effective population size (<code>neff</code>, i.e., $N_e$), number of genealogy edges in that interval (<code>nedges</code>; i.e., $k$), and the interval length (<code>stop</code> - <code>start</code>). From this we have all the information needed to compute the probability of coalescence.</p> <p>To compute the likelihood of our observation, we model each coalescent event as a exponential waiting time given the rate of coalescence. For each species tree interval, we also must compute the likelihood that no coalescence occurs during the remaining end of the interval. This set of calculations is the multispecies coalescent (MSC) likelihood. Below we describe some ways it is implemented.</p> In\u00a0[7]: Copied! <pre># log-likelihood of 100 unlinked genealogies\nipcoal.msc.get_msc_loglik(S, G, I)\n</pre> # log-likelihood of 100 unlinked genealogies ipcoal.msc.get_msc_loglik(S, G, I) Out[7]: <pre>7973.467153781378</pre> <p>Note, this function is generally intended for educational purposes. It is easy to use and understand as it takes the data objects (S, G, I) directly and returns a value. However, in practice users will want to use the much faster implementation below. For comparision, we show the speed for this implementation in the cell below.</p> In\u00a0[8]: Copied! <pre>%%timeit\nipcoal.msc.get_msc_loglik(S, G, I)\n</pre> %%timeit ipcoal.msc.get_msc_loglik(S, G, I) <pre>51.8 ms \u00b1 12.8 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</pre> In\u00a0[9]: Copied! <pre># get the embedding and encoding as separate arrays\na0, a1 = ipcoal.msc.get_genealogy_embedding_arrays(S, G, I)\n</pre>  # get the embedding and encoding as separate arrays a0, a1 = ipcoal.msc.get_genealogy_embedding_arrays(S, G, I) In\u00a0[10]: Copied! <pre># log-likelihood of 100 unlinked genealogies\nipcoal.msc.get_msc_loglik_from_embedding(a0)\n</pre> # log-likelihood of 100 unlinked genealogies ipcoal.msc.get_msc_loglik_from_embedding(a0) Out[10]: <pre>7973.467153781378</pre> In\u00a0[11]: Copied! <pre>%%timeit\nipcoal.msc.get_msc_loglik_from_embedding(a0)\n</pre> %%timeit ipcoal.msc.get_msc_loglik_from_embedding(a0) <pre>165 \u03bcs \u00b1 14.4 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[12]: Copied! <pre># [todo] show example of changing Ne for optimization\n</pre> # [todo] show example of changing Ne for optimization In\u00a0[13]: Copied! <pre># [todo] show example using the dists argument of `get_msc_loglik_from_embedding`.\n</pre> # [todo] show example using the dists argument of `get_msc_loglik_from_embedding`. In\u00a0[14]: Copied! <pre># to get the example species tree, genealogy, and mapping data\nipcoal.msc.get_test_data()\n</pre> # to get the example species tree, genealogy, and mapping data ipcoal.msc.get_test_data() Out[14]: <pre>(&lt;toytree.ToyTree at 0x724a8c7a8770&gt;,\n &lt;toytree.ToyTree at 0x724a8cdad760&gt;,\n {'A': ['0', '1', '2'], 'B': ['3', '4'], 'C': ['5'], 'D': ['6']})</pre> <p>You can optionally select the number of simulated genealogies using <code>nloci</code>. By default their lengths are each 1, such that the simulated genealogies are unlinked, but you can set <code>nsites</code> to make them into longer treesequences. Under the hood this will initialize an <code>ipcoal.Model</code> object using the example species tree and all other arguments at defaults. It will then call <code>Model.sim_trees</code> using the <code>nloci</code> and <code>nsites</code> args. This is primarily used for setting up simple tests.</p> In\u00a0[15]: Copied! <pre># to simulate multiple loci, or longer loci, using the example dataset\nipcoal.msc.get_test_data(nloci=2, nsites=100, seed=123)\n</pre> # to simulate multiple loci, or longer loci, using the example dataset ipcoal.msc.get_test_data(nloci=2, nsites=100, seed=123) Out[15]: <pre>(&lt;toytree.ToyTree at 0x724a8c88a9f0&gt;,\n [&lt;toytree.ToyTree at 0x724a8cdada00&gt;, &lt;toytree.ToyTree at 0x724a8c88ae10&gt;],\n {'A': ['A_0', 'A_1', 'A_2'], 'B': ['B_0', 'B_1'], 'C': ['C_0'], 'D': ['D_0']})</pre> In\u00a0[16]: Copied! <pre>ipcoal.msc.get_test_model()\n</pre> ipcoal.msc.get_test_model() Out[16]: <pre>&lt;ipcoal.model.Model at 0x724a8c888e30&gt;</pre> In\u00a0[17]: Copied! <pre># overrides Ne and nsamples to return a genealogy and imap from S\ng, i = ipcoal.msc.get_embedded_genealogy(S, Ne=2e5, nsamples=2, seed_trees=1234)\n# draw the genealogy embedded in S\nipcoal.draw.draw_embedded_genealogy(S, g, i);\n</pre> # overrides Ne and nsamples to return a genealogy and imap from S g, i = ipcoal.msc.get_embedded_genealogy(S, Ne=2e5, nsamples=2, seed_trees=1234) # draw the genealogy embedded in S ipcoal.draw.draw_embedded_genealogy(S, g, i); idx=5 Ne=1e+05 Tc=1 Tg=2e+05idx=3 Ne=1e+05 Tc=3 Tg=6e+05idx=4 Ne=1e+05 Tc=1 Tg=2e+05idx=2 Ne=1e+05 Tc=2 Tg=4e+05idx=0 Ne=1e+05 Tc=1 Tg=2e+05idx=1 Ne=1e+05 Tc=1 Tg=2e+05idx=6 Ne=1e+05 Tc=0 Tg=0A_0A_1B_1B_0C_0C_1D_0D_1node=1node=2node=0node=5node=6node=7node=11node=3node=4node=10node=8node=9node=12node=13node=1404000008000001200000 In\u00a0[18]: Copied! <pre>ipcoal.msc.get_genealogy_embedding_table(S, G[0], I).shape\n</pre> ipcoal.msc.get_genealogy_embedding_table(S, G[0], I).shape Out[18]: <pre>(13, 8)</pre> In\u00a0[19]: Copied! <pre>ipcoal.msc.get_genealogy_embedding_table(S, G, I).shape\n</pre> ipcoal.msc.get_genealogy_embedding_table(S, G, I).shape Out[19]: <pre>(1300, 8)</pre> In\u00a0[20]: Copied! <pre>arr, _ = ipcoal.msc.get_genealogy_embedding_arrays(S, G, I)\narr.shape\n</pre> arr, _ = ipcoal.msc.get_genealogy_embedding_arrays(S, G, I) arr.shape Out[20]: <pre>(100, 13, 7)</pre>"},{"location":"MSC_likelihood/#multispecies-coalescent-msc-likelihood","title":"Multispecies Coalescent (MSC) Likelihood\u00b6","text":"<p>A core feature of the coalescent model, beyond the ability to simulate coalescent trees, is the ability to calculate the likelihood of observed trees given a model of a population (i.e., Ne parameter). This extends to the multispecies coalescent (MSC), where the coalescent is essentially applied to many different intervals that are stitched together into a larger model. Here we demonstrate how to calculate the likelihood of an observed set of genealogical trees given a species tree model.</p>"},{"location":"MSC_likelihood/#tldr","title":"tldr;\u00b6","text":"<p>The likelihood of one or more gene trees given a parameterized species tree can be calculated using <code>get_msc_loglik</code>.</p>"},{"location":"MSC_likelihood/#test-dataset","title":"Test dataset\u00b6","text":"<p>A MSC data set is composed of a species tree (demographic model), one or more genealogies that can be embedded in that species tree, and an imap dictionary that maps species tree tip names to genealogy tip names. We can generate a simple test dataset for studying the MSC model using <code>msc.get_test_data</code>. This returns a species tree (S), a collection of embedded genealogies (G), and a mapping dictionary (I). These are described further below.</p>"},{"location":"MSC_likelihood/#genealogy-embedding-table","title":"Genealogy embedding table\u00b6","text":"<p>The first step of a multispecies coalescent analysis involves decomposing the data (S, G, I) into a table. Let's start with our example test dataset. This includes a species tree (S) composing four lineages and collection of genealogies (G) each composing seven samples. Each genealogy has 3 samples from lineage A, 2 from lineage B, and 1 from C and D. This is described in the mapping dictionary (I), which maps species names to lists of genealogy tip names. We can pass these three variables to the function <code>draw_embedded_genealogy</code> to create a visualization of the genealogy embedding for the first genealogy.</p>"},{"location":"MSC_likelihood/#calculate-msc-likelihood","title":"Calculate MSC likelihood\u00b6","text":"<p>The function <code>get_msc_loglik</code> returns the summed log-likelihood of all trees in G, given the model S, and their mapping in I.</p>"},{"location":"MSC_likelihood/#faster-implementations","title":"Faster implementations\u00b6","text":"<p>A much faster implementation is also provided in <code>get_msc_loglik_from_embedding</code>. This makes use of the <code>numba</code> library to perform just-in-time compilation. This is a workaround for writing very fast Python code that runs at a similar speed to compiled languages like C. To use this method you should first generate the genealogy embedding data as a numpy float array like below, and then pass the array to the likelihood function. You can see from the <code>%%timeit</code> call below which measures the running time for the cell, that this implementation runs about &gt;250X faster.</p>"},{"location":"MSC_likelihood/#parameter-optimization","title":"Parameter optimization\u00b6","text":"<p>The problem of parameter optimization is outside of the scope of this documentation, as there are many approaches. These typically fall into the categories of either Maximum Likelihood or Bayesian MCMC. In either case, we must propose a set of parameters, calculate the likelihood, and then propose a different set of parameters based on some proposal mechanism, and either accept or reject the new parameter set based on some acceptance criterion.</p> <p>Note that some types of proposals are very easy to implement, such as proposing different Ne values which requires only changing their value in the embedding array; while other types of moves require greater effort, such as proposing a different divergence time value, which can require re-embedding the genealogies (i.e., re-creating the embedding arrays). Efficient algorithms can be written for the latter, but we have not put great effort into this yet.</p>"},{"location":"MSC_likelihood/#linked-trees","title":"Linked trees\u00b6","text":"<p>While the MSC model was originally developed to describe an unlinked distribution of trees, it can also be applied to a sample of linked trees. In this case the key difference is that each tree is not treated equally. Instead, trees should be weighted relative to their contribution to the data being studied. ...</p>"},{"location":"MSC_likelihood/#utilities","title":"Utilities\u00b6","text":"<p>Here we provide a short description of several functions available from the <code>ipcoal.msc</code> subpackage.</p>"},{"location":"MSC_likelihood/#get_test_data","title":"get_test_data\u00b6","text":"<p>This returns an example dataset composed of a species tree (ToyTree), gene tree (ToyTree), and imap dictionary (dict). The species tree describes a 4-tip imbalanced tree <code>(((A,B),C),D);</code> with equal spaced internodes and a root height of 1e6 generations. Each species tree interval has Ne=1e5. Each genealogy samples 3 tips from 'A', 2 from 'B', and 1 from 'C' and 'D'.</p>"},{"location":"MSC_likelihood/#get_test_model","title":"get_test_model\u00b6","text":"<p>This returns an <code>ipcoal.Model</code> object initialized with the example 4-tip species tree model from <code>get_test_data</code>. This is primarily used for testing.</p>"},{"location":"MSC_likelihood/#get_embedded_genealogy","title":"get_embedded_genealogy\u00b6","text":"<p>This is a convenience function to initialize an <code>ipcoal.Model</code> as <code>ipcoal.Model(tree=S, **kwargs)</code> where you can pass additional kwargs to initialize the model (such as nsamples). It then calls <code>sim_trees</code> to simulate and return one genealogy and an imap dict. One example usage for this is that you have a species tree and just want to sample one or more random genealogies to embed and visualize in one simple step, like below.</p>"},{"location":"MSC_likelihood/#get_genealogy_embedding_table","title":"get_genealogy_embedding_table\u00b6","text":"<p>The genealogy embedding table is returned as a <code>pandas.DataFrame</code>. This is easy to read and interpret. If you enter a single genealogy then the returned table will be composed only the intervals in that genealogy, but if you enter multiple genealogies then each is listed sequentially in the table, labeled by a different genealogy index (gidx column).</p>"},{"location":"MSC_likelihood/#get_genealogy_embedding_arrays","title":"get_genealogy_embedding_arrays\u00b6","text":"<p>The genealogy embedding array is similar to the genealogy embedding table, just formatted differently. It is less user-friendly to read and interpret, but much faster for operations, and so this is what is generally used under the hood. It separates the first 7 columns of the genealogy embedding table from a second array which contains info on which edges are represented in each interval. The latter array is not needed for MSC calculations. In contrast to the 2D genealogy embedding table, the genealogy embedding array is 3D (ntrees, nrows, ncolumns), storing each genealogy as a separate 2D embedding array.</p>"},{"location":"Model_class/","title":"Model class","text":"In\u00a0[1]: Copied! <pre>import ipcoal\nimport toytree\nimport msprime\n</pre> import ipcoal import toytree import msprime In\u00a0[2]: Copied! <pre># initialize a Model object\nipcoal.Model(Ne=1000, nsamples=10)\n</pre> # initialize a Model object ipcoal.Model(Ne=1000, nsamples=10) Out[2]: <pre>&lt;ipcoal.model.Model at 0x7ad2b4304260&gt;</pre> In\u00a0[3]: Copied! <pre># a single population model with constant Ne\nipcoal.Model(tree=None, Ne=1000)\n</pre> # a single population model with constant Ne ipcoal.Model(tree=None, Ne=1000) Out[3]: <pre>&lt;ipcoal.model.Model at 0x7ad21e2a7e60&gt;</pre> In\u00a0[4]: Copied! <pre># a single population model with constant Ne and other args\nipcoal.Model(Ne=1000, nsamples=5, mut=1e-8, recomb=1-9)\n</pre> # a single population model with constant Ne and other args ipcoal.Model(Ne=1000, nsamples=5, mut=1e-8, recomb=1-9) Out[4]: <pre>&lt;ipcoal.model.Model at 0x7ad21e2f3890&gt;</pre> In\u00a0[5]: Copied! <pre># get an imbalanced tree with 3 tips\nsptree = toytree.rtree.imbtree(ntips=3)\n</pre> # get an imbalanced tree with 3 tips sptree = toytree.rtree.imbtree(ntips=3) In\u00a0[6]: Copied! <pre># or, get a random tree w/ equal spaced nodes and set root height\nsptree = toytree.rtree.unittree(ntips=3, treeheight=1e5)\n</pre> # or, get a random tree w/ equal spaced nodes and set root height sptree = toytree.rtree.unittree(ntips=3, treeheight=1e5) In\u00a0[7]: Copied! <pre># or, define a custom tree from newick string\nsptree = toytree.tree(\"((A:1,B:1):1,C:2);\")\n</pre> # or, define a custom tree from newick string sptree = toytree.tree(\"((A:1,B:1):1,C:2);\") In\u00a0[8]: Copied! <pre># set the branch lengths on a tree explicitly\nsptree = sptree.set_node_data(\"height\", {3: 5e4, 4: 1e5})\n</pre> # set the branch lengths on a tree explicitly sptree = sptree.set_node_data(\"height\", {3: 5e4, 4: 1e5}) In\u00a0[9]: Copied! <pre># or, set the branch lengths by stretching the tree\nsptree = sptree.mod.edges_scale_to_root_height(1e5)\n</pre> # or, set the branch lengths by stretching the tree sptree = sptree.mod.edges_scale_to_root_height(1e5) In\u00a0[10]: Copied! <pre># draw the tree to examine the relationships and div times\nsptree.draw(ts='p');\n</pre> # draw the tree to examine the relationships and div times sptree.draw(ts='p'); 01234ABC050000100000 In\u00a0[11]: Copied! <pre># initialize a Model from a species tree\nipcoal.Model(tree=sptree, Ne=1000)\n</pre> # initialize a Model from a species tree ipcoal.Model(tree=sptree, Ne=1000) Out[11]: <pre>&lt;ipcoal.model.Model at 0x7ad21def3860&gt;</pre> In\u00a0[12]: Copied! <pre># simulate many independent trees with 2 samples from a population\nNE = 10_000\nmod = ipcoal.Model(Ne=NE, nsamples=2, seed_trees=123)\nmod.sim_trees(10_000)\n\n# get mean root node height of all trees\ntrees = [toytree.tree(i) for i in mod.df.genealogy]\navg_time = sum(i.treenode.height for i in trees) / len(trees)\n\n# return result\nf\"Avg time to first coalescence = {avg_time:.2f} generation, or {avg_time/NE:.2f}Ne\"\n</pre> # simulate many independent trees with 2 samples from a population NE = 10_000 mod = ipcoal.Model(Ne=NE, nsamples=2, seed_trees=123) mod.sim_trees(10_000)  # get mean root node height of all trees trees = [toytree.tree(i) for i in mod.df.genealogy] avg_time = sum(i.treenode.height for i in trees) / len(trees)  # return result f\"Avg time to first coalescence = {avg_time:.2f} generation, or {avg_time/NE:.2f}Ne\" Out[12]: <pre>'Avg time to first coalescence = 20196.12 generation, or 2.02Ne'</pre> In\u00a0[13]: Copied! <pre># set constant Ne to a single population\nipcoal.Model(Ne=1000)\n</pre> # set constant Ne to a single population ipcoal.Model(Ne=1000) Out[13]: <pre>&lt;ipcoal.model.Model at 0x7ad21def3d10&gt;</pre> In\u00a0[14]: Copied! <pre># set constant Ne to all Nodes on a species tree\nipcoal.Model(tree=sptree, Ne=1000)\n</pre> # set constant Ne to all Nodes on a species tree ipcoal.Model(tree=sptree, Ne=1000) Out[14]: <pre>&lt;ipcoal.model.Model at 0x7ad21e5e1040&gt;</pre> In\u00a0[15]: Copied! <pre># set variable Ne values to Nodes on a species tree\nipcoal.Model(tree=sptree, Ne={0: 1000, 1: 1000, 2: 1000, 3: 2000, 4: 2000})\n</pre> # set variable Ne values to Nodes on a species tree ipcoal.Model(tree=sptree, Ne={0: 1000, 1: 1000, 2: 1000, 3: 2000, 4: 2000}) Out[15]: <pre>&lt;ipcoal.model.Model at 0x7ad21c66a900&gt;</pre> In\u00a0[16]: Copied! <pre># set variable Ne to each Node\nsptree = sptree.set_node_data(\"Ne\", {0: 1e4, 1: 2e4, 2: 3e4, 3: 5e4, 4: 1e5})\n</pre> # set variable Ne to each Node sptree = sptree.set_node_data(\"Ne\", {0: 1e4, 1: 2e4, 2: 3e4, 3: 5e4, 4: 1e5}) In\u00a0[17]: Copied! <pre># set variable Ne to some Nodes and others to a default\nsptree = sptree.set_node_data(\"Ne\", {0: 4e4, 1: 3e4}, default=1e4)\n</pre> # set variable Ne to some Nodes and others to a default sptree = sptree.set_node_data(\"Ne\", {0: 4e4, 1: 3e4}, default=1e4) In\u00a0[18]: Copied! <pre># visualize Ne as edge widths projected between size 2-10\nsptree.draw('p', edge_widths=(\"Ne\", 2, 10));\n</pre> # visualize Ne as edge widths projected between size 2-10 sptree.draw('p', edge_widths=(\"Ne\", 2, 10)); 01234ABC050000100000 In\u00a0[19]: Copied! <pre># finally, we can enter the tree to set Ne values in the Model\nipcoal.Model(tree=sptree)\n</pre> # finally, we can enter the tree to set Ne values in the Model ipcoal.Model(tree=sptree) Out[19]: <pre>&lt;ipcoal.model.Model at 0x7ad21c6766f0&gt;</pre> In\u00a0[20]: Copied! <pre>ipcoal.Model(Ne=1000, nsamples=5).get_imap_dict()\n</pre> ipcoal.Model(Ne=1000, nsamples=5).get_imap_dict() Out[20]: <pre>{'p': ['p_0', 'p_1', 'p_2', 'p_3', 'p_4']}</pre> In\u00a0[21]: Copied! <pre>ipcoal.Model(sptree, nsamples=2).get_imap_dict()\n</pre> ipcoal.Model(sptree, nsamples=2).get_imap_dict() Out[21]: <pre>{'A': ['A_0', 'A_1'], 'B': ['B_0', 'B_1'], 'C': ['C_0', 'C_1']}</pre> In\u00a0[22]: Copied! <pre>ipcoal.Model(sptree, nsamples={\"A\": 1, \"B\": 2, \"C\": 3}).get_imap_dict()\n</pre> ipcoal.Model(sptree, nsamples={\"A\": 1, \"B\": 2, \"C\": 3}).get_imap_dict() Out[22]: <pre>{'A': ['A_0'], 'B': ['B_0', 'B_1'], 'C': ['C_0', 'C_1', 'C_2']}</pre> <p>Finally, using visualizations we can validate the setting for different numbers of samples in each population.</p> In\u00a0[23]: Copied! <pre>mod = ipcoal.Model(sptree, nsamples={\"A\": 3, \"B\": 2, \"C\": 1}, seed_trees=123)\nmod.sim_trees(1)\nmod.draw_demography(0);\n</pre> mod = ipcoal.Model(sptree, nsamples={\"A\": 3, \"B\": 2, \"C\": 1}, seed_trees=123) mod.sim_trees(1) mod.draw_demography(0); idx=3 Ne=1e+04 Tc=2.5 Tg=5e+04idx=2 Ne=1e+04 Tc=5 Tg=1e+05idx=0 Ne=4e+04 Tc=0.625 Tg=5e+04idx=1 Ne=3e+04 Tc=0.833 Tg=5e+04idx=4 Ne=1e+04 Tc=0 Tg=0A_0A_2A_1B_0B_1C_0node=1node=2node=3node=6node=4node=5node=7node=0node=8node=9node=10050000100000 In\u00a0[24]: Copied! <pre># draw the admixture_edges scenario to validate its set up\nsptree.draw(ts='p', admixture_edges=[(1, 2)]);\n</pre> # draw the admixture_edges scenario to validate its set up sptree.draw(ts='p', admixture_edges=[(1, 2)]); 01234ABC050000100000 In\u00a0[25]: Copied! <pre># admixture of 10% from 1-&gt;2 at time=20K\namodel = ipcoal.Model(sptree, Ne=1e4, admixture_edges=[(1, 2, 20000, 0.1)], seed_trees=123)\n\n# simulate 100 unlinked genealogies under this model\namodel.sim_trees(100)\n\n# visualize discordance as a cloud tree\ncanvas, axes, marks = amodel.draw_cloud_tree(scale_bar=True);\n\n# highlighting admixture timing at t=20K gens\naxes.hlines(20000, style={\"stroke\": \"red\", \"stroke-dasharray\": \"5,2\"});\n</pre> # admixture of 10% from 1-&gt;2 at time=20K amodel = ipcoal.Model(sptree, Ne=1e4, admixture_edges=[(1, 2, 20000, 0.1)], seed_trees=123)  # simulate 100 unlinked genealogies under this model amodel.sim_trees(100)  # visualize discordance as a cloud tree canvas, axes, marks = amodel.draw_cloud_tree(scale_bar=True);  # highlighting admixture timing at t=20K gens axes.hlines(20000, style={\"stroke\": \"red\", \"stroke-dasharray\": \"5,2\"}); CAB0100000200000 <p>Here is a similar scenario but we have set the timing of the introgression to occur further back in time, at 50% of the way back along the interval during which edges 1 and 2 both exist.</p> In\u00a0[26]: Copied! <pre># admixture of 10% from 1-&gt;2 at time=50% of way back on shared history\namodel = ipcoal.Model(sptree, Ne=1e4, admixture_edges=[(1, 2, 0.5, 0.1)], seed_trees=123)\n\n# simulate 100 unlinked genealogies under this model\namodel.sim_trees(100)\n\n# visualize discordance as a cloud tree\namodel.draw_cloud_tree(scale_bar=True);\n</pre> # admixture of 10% from 1-&gt;2 at time=50% of way back on shared history amodel = ipcoal.Model(sptree, Ne=1e4, admixture_edges=[(1, 2, 0.5, 0.1)], seed_trees=123)  # simulate 100 unlinked genealogies under this model amodel.sim_trees(100)  # visualize discordance as a cloud tree amodel.draw_cloud_tree(scale_bar=True); CAB0100000200000 In\u00a0[27]: Copied! <pre># migration at rate 1e-5 from 1-&gt;2 from time 10K-20K gens ago\namodel = ipcoal.Model(sptree, Ne=1e4, admixture_edges=[(1, 2, (10000, 20000), 2e-5)], seed_trees=123)\n\n# simulate 100 unlinked genealogies under this model\namodel.sim_trees(100)\n\n# visualize discordance as a cloud tree\namodel.draw_cloud_tree(scale_bar=True);\n</pre> # migration at rate 1e-5 from 1-&gt;2 from time 10K-20K gens ago amodel = ipcoal.Model(sptree, Ne=1e4, admixture_edges=[(1, 2, (10000, 20000), 2e-5)], seed_trees=123)  # simulate 100 unlinked genealogies under this model amodel.sim_trees(100)  # visualize discordance as a cloud tree amodel.draw_cloud_tree(scale_bar=True); CAB0100000200000 In\u00a0[28]: Copied! <pre># migration at rate 2e-5 from 1-&gt;2 from time 10%-50% of their time \namodel = ipcoal.Model(sptree, Ne=1e4, admixture_edges=[(1, 2, (0.1, 0.5), 2e-5)], seed_trees=123)\n\n# simulate 100 unlinked genealogies under this model\namodel.sim_trees(100)\n\n# visualize discordance as a cloud tree\namodel.draw_cloud_tree(scale_bar=True);\n</pre> # migration at rate 2e-5 from 1-&gt;2 from time 10%-50% of their time  amodel = ipcoal.Model(sptree, Ne=1e4, admixture_edges=[(1, 2, (0.1, 0.5), 2e-5)], seed_trees=123)  # simulate 100 unlinked genealogies under this model amodel.sim_trees(100)  # visualize discordance as a cloud tree amodel.draw_cloud_tree(scale_bar=True); CAB0100000200000 <p>Finally, you can set more than one migration or admixture event at a time by simply entering them as multiple tuples. In this example we set bi-directional migration between B and C.</p> In\u00a0[29]: Copied! <pre># migration at rate 1e-5 from 1&lt;-&gt;2 from time 0%-50% of their time \namodel = ipcoal.Model(\n    sptree, Ne=1e4, seed_trees=123,\n    admixture_edges=[\n        (1, 2, (0.0, 0.5), 1e-5),\n        (2, 1, (0.0, 0.5), 1e-5),\n    ])\n\n# simulate 100 unlinked genealogies under this model\namodel.sim_trees(100)\n\n# visualize discordance as a cloud tree\nc, a, m = amodel.draw_cloud_tree(scale_bar=True);\n</pre> # migration at rate 1e-5 from 1&lt;-&gt;2 from time 0%-50% of their time  amodel = ipcoal.Model(     sptree, Ne=1e4, seed_trees=123,     admixture_edges=[         (1, 2, (0.0, 0.5), 1e-5),         (2, 1, (0.0, 0.5), 1e-5),     ])  # simulate 100 unlinked genealogies under this model amodel.sim_trees(100)  # visualize discordance as a cloud tree c, a, m = amodel.draw_cloud_tree(scale_bar=True); CAB050000100000150000200000 In\u00a0[30]: Copied! <pre>model = ipcoal.Model(Ne=1000, nsamples=5, mut=2e-8, recomb=0, seed_trees=123, seed_mutations=123, store_tree_sequences=True)\nmodel.sim_loci(nloci=1, nsites=10000)\nmodel.draw_genealogy(0, show_substitutions=True, layout='d');\n</pre> model = ipcoal.Model(Ne=1000, nsamples=5, mut=2e-8, recomb=0, seed_trees=123, seed_mutations=123, store_tree_sequences=True) model.sim_loci(nloci=1, nsites=10000) model.draw_genealogy(0, show_substitutions=True, layout='d'); p_1p_2p_4p_0p_3id: 0 site: 0 time: 119 mtype: 0id: 1 site: 1 time: 1230 mtype: 0010002000tree in interval 0 (sites 0-10000) <p>Next we can see that by cranking up the mutation rate by an order of magnitude the number of mutations on each branch is much greater.</p> In\u00a0[31]: Copied! <pre>model = ipcoal.Model(Ne=1000, nsamples=5, mut=2e-7, recomb=0, seed_trees=123, seed_mutations=123, store_tree_sequences=True)\nmodel.sim_loci(nloci=1, nsites=10000)\nmodel.draw_genealogy(0, show_substitutions=True, layout='d');\n</pre> model = ipcoal.Model(Ne=1000, nsamples=5, mut=2e-7, recomb=0, seed_trees=123, seed_mutations=123, store_tree_sequences=True) model.sim_loci(nloci=1, nsites=10000) model.draw_genealogy(0, show_substitutions=True, layout='d'); p_1p_2p_4p_0p_3id: 0 site: 0 time: 1740 mtype: 0id: 1 site: 1 time: 770 mtype: 0id: 2 site: 2 time: 1658 mtype: 0id: 3 site: 3 time: 985 mtype: 0id: 4 site: 4 time: 551 mtype: 0id: 5 site: 5 time: 2361 mtype: 0id: 6 site: 6 time: 1050 mtype: 0id: 7 site: 7 time: 2220 mtype: 0id: 8 site: 8 time: 2814 mtype: 0id: 9 site: 9 time: 2201 mtype: 0id: 10 site: 10 time: 1764 mtype: 0id: 11 site: 11 time: 2810 mtype: 0id: 12 site: 12 time: 413 mtype: 0id: 13 site: 13 time: 409 mtype: 0id: 14 site: 14 time: 1364 mtype: 0id: 15 site: 15 time: 377 mtype: 0id: 16 site: 16 time: 199 mtype: 0010002000tree in interval 0 (sites 0-10000) In\u00a0[32]: Copied! <pre># define a mutation Map over 3 intervals from 0-30K\nrate_map = msprime.RateMap(\n    position=[0, 10_000, 20_000, 30_000],\n    rate=[0, 1e-9, 1e-7],\n)\n\n# set the rate_map for mutations\nmodel = ipcoal.Model(nsamples=10, Ne=10000, mut=rate_map, store_tree_sequences=True, seed_trees=123, seed_mutations=123)\nmodel.sim_loci(1, 30_000)\nmodel.draw_tree_sequence(width=700);\n</pre> # define a mutation Map over 3 intervals from 0-30K rate_map = msprime.RateMap(     position=[0, 10_000, 20_000, 30_000],     rate=[0, 1e-9, 1e-7], )  # set the rate_map for mutations model = ipcoal.Model(nsamples=10, Ne=10000, mut=rate_map, store_tree_sequences=True, seed_trees=123, seed_mutations=123) model.sim_loci(1, 30_000) model.draw_tree_sequence(width=700); 0100002000030000idx: 0 interval: (0 - 11815) tmrca: 25312.06idx: 1 interval: (11815 - 13951) tmrca: 19167.32idx: 2 interval: (13951 - 28791) tmrca: 19167.32idx: 3 interval: (28791 - 30000) tmrca: 19167.32p0-9p0-7p0-1p0-2p0-5p0-8p0-0p0-3p0-4p0-6p0-7p0-9p0-1p0-2p0-5p0-8p0-0p0-3p0-4p0-6p0-1p0-2p0-5p0-8p0-0p0-3p0-4p0-6p0-7p0-9id: 0 pos: 0 time: 1052 mtype: 0id: 1 pos: 1 time: 5047 mtype: 0id: 2 pos: 2 time: 14980 mtype: 0id: 3 pos: 3 time: 16553 mtype: 0id: 4 pos: 4 time: 1951 mtype: 0id: 5 pos: 5 time: 5594 mtype: 0id: 6 pos: 6 time: 14291 mtype: 0id: 7 pos: 7 time: 16173 mtype: 0id: 8 pos: 8 time: 11838 mtype: 0id: 9 pos: 9 time: 7943 mtype: 0id: 10 pos: 10 time: 6042 mtype: 0id: 11 pos: 11 time: 6074 mtype: 0id: 12 pos: 12 time: 14075 mtype: 0id: 13 pos: 13 time: 10416 mtype: 0id: 14 pos: 14 time: 1269 mtype: 0id: 15 pos: 15 time: 220 mtype: 0id: 16 pos: 16 time: 8486 mtype: 0id: 17 pos: 17 time: 9432 mtype: 0id: 18 pos: 18 time: 1068 mtype: 0id: 19 pos: 19 time: 202 mtype: 0id: 20 pos: 20 time: 2410 mtype: 0id: 21 pos: 21 time: 1392 mtype: 0id: 22 pos: 22 time: 15234 mtype: 0id: 23 pos: 23 time: 368 mtype: 0id: 24 pos: 24 time: 1680 mtype: 0id: 25 pos: 25 time: 6061 mtype: 0id: 26 pos: 26 time: 13862 mtype: 0id: 27 pos: 27 time: 6171 mtype: 0id: 28 pos: 28 time: 12363 mtype: 0id: 29 pos: 29 time: 23 mtype: 0id: 30 pos: 30 time: 12498 mtype: 0id: 31 pos: 31 time: 2464 mtype: 0id: 32 pos: 32 time: 12908 mtype: 0id: 33 pos: 33 time: 4949 mtype: 0id: 34 pos: 34 time: 13114 mtype: 0id: 35 pos: 35 time: 14191 mtype: 0id: 36 pos: 36 time: 1707 mtype: 0id: 37 pos: 37 time: 3240 mtype: 0id: 38 pos: 38 time: 2754 mtype: 0id: 39 pos: 39 time: 12331 mtype: 0id: 40 pos: 40 time: 12956 mtype: 0id: 41 pos: 41 time: 8796 mtype: 0id: 42 pos: 42 time: 1213 mtype: 0id: 43 pos: 43 time: 144 mtype: 0id: 44 pos: 44 time: 16335 mtype: 0id: 45 pos: 45 time: 13746 mtype: 0id: 46 pos: 46 time: 10179 mtype: 0id: 47 pos: 47 time: 652 mtype: 0id: 48 pos: 48 time: 3128 mtype: 0id: 49 pos: 49 time: 896 mtype: 0id: 50 pos: 50 time: 16711 mtype: 0id: 51 pos: 51 time: 1052 mtype: 0id: 52 pos: 52 time: 9332 mtype: 0id: 53 pos: 53 time: 2357 mtype: 0id: 54 pos: 54 time: 1467 mtype: 0id: 55 pos: 55 time: 12636 mtype: 0id: 56 pos: 56 time: 2676 mtype: 0id: 57 pos: 57 time: 7658 mtype: 0id: 58 pos: 58 time: 12217 mtype: 0id: 59 pos: 59 time: 4057 mtype: 0id: 60 pos: 60 time: 4972 mtype: 0id: 61 pos: 61 time: 8498 mtype: 0id: 62 pos: 62 time: 16020 mtype: 0id: 63 pos: 63 time: 11925 mtype: 0id: 64 pos: 64 time: 18272 mtype: 0id: 65 pos: 65 time: 2706 mtype: 0id: 66 pos: 66 time: 410 mtype: 0id: 67 pos: 67 time: 3193 mtype: 0id: 68 pos: 68 time: 19062 mtype: 0id: 69 pos: 69 time: 6991 mtype: 0id: 70 pos: 70 time: 15407 mtype: 0id: 71 pos: 71 time: 18693 mtype: 0p0-1p0-2p0-5p0-6p0-8p0-4p0-0p0-3p0-7p0-9id: 72 pos: 72 time: 1027 mtype: 0id: 73 pos: 73 time: 3858 mtype: 0id: 74 pos: 74 time: 18346 mtype: 0id: 75 pos: 75 time: 7657 mtype: 0id: 76 pos: 76 time: 13975 mtype: 0id: 77 pos: 77 time: 4949 mtype: 0id: 78 pos: 78 time: 13473 mtype: 0id: 79 pos: 79 time: 14236 mtype: 0 In\u00a0[33]: Copied! <pre># the default subst model is \"JC69\"\nmodel = ipcoal.Model(Ne=1000, subst_model=\"JC69\")\nprint(f\"states: {model.subst_model.alleles}\")\nprint(f\"root distribution: {model.subst_model.root_distribution}\")\nprint(f\"transition matrix:\\n{model.subst_model.transition_matrix}\")\n</pre> # the default subst model is \"JC69\" model = ipcoal.Model(Ne=1000, subst_model=\"JC69\") print(f\"states: {model.subst_model.alleles}\") print(f\"root distribution: {model.subst_model.root_distribution}\") print(f\"transition matrix:\\n{model.subst_model.transition_matrix}\") <pre>states: ['A', 'C', 'G', 'T']\nroot distribution: [0.25 0.25 0.25 0.25]\ntransition matrix:\n[[0.         0.33333333 0.33333333 0.33333333]\n [0.33333333 0.         0.33333333 0.33333333]\n [0.33333333 0.33333333 0.         0.33333333]\n [0.33333333 0.33333333 0.33333333 0.        ]]\n</pre> <p>Other simple models that can be set by name include \"binary\", \"pam\", \"infinite_alleles\", and \"blosum62\".</p> In\u00a0[34]: Copied! <pre># a simple binary model\nmodel = ipcoal.Model(Ne=1000, subst_model=\"binary\")\nprint(f\"states: {model.subst_model.alleles}\")\nprint(f\"root distribution: {model.subst_model.root_distribution}\")\nprint(f\"transition matrix:\\n{model.subst_model.transition_matrix}\")\n</pre> # a simple binary model model = ipcoal.Model(Ne=1000, subst_model=\"binary\") print(f\"states: {model.subst_model.alleles}\") print(f\"root distribution: {model.subst_model.root_distribution}\") print(f\"transition matrix:\\n{model.subst_model.transition_matrix}\") <pre>states: ['0', '1']\nroot distribution: [1. 0.]\ntransition matrix:\n[[0. 1.]\n [1. 0.]]\n</pre> <p>Using a more complex substitution model (GTR) requires settings parameters of the model using <code>msprime.HKY</code>, <code>msprime.GTR</code>, or <code>msprime.MutationModel</code> classes.</p> In\u00a0[35]: Copied! <pre>GTR = msprime.GTR(\n    relative_rates=[0.2, 0.2, 0.3, 0.2, 0.2, 0.3], # {AC}, {AG}, {AT}, {CG}, {CT}, {GT}\n    equilibrium_frequencies=[0.3,0.2,0.2,0.3],     # A, C, G, T\n    state_independent=False,\n)\nmodel = ipcoal.Model(Ne=10000, mut=1e-6, nsamples=5, subst_model=GTR, seed_trees=123, seed_mutations=123)\nmodel.sim_loci(1, 100)\nmodel.draw_seqview(scrollable=True, show_text=True);\n</pre> GTR = msprime.GTR(     relative_rates=[0.2, 0.2, 0.3, 0.2, 0.2, 0.3], # {AC}, {AG}, {AT}, {CG}, {CT}, {GT}     equilibrium_frequencies=[0.3,0.2,0.2,0.3],     # A, C, G, T     state_independent=False, ) model = ipcoal.Model(Ne=10000, mut=1e-6, nsamples=5, subst_model=GTR, seed_trees=123, seed_mutations=123) model.sim_loci(1, 100) model.draw_seqview(scrollable=True, show_text=True); p_0AAAATTATTGATATGTATGAACGAATTTGTTAATAATAGAGATACAACCAAACGCTCATCTGCCACGTCCGAGACGTCCAAACCTTCTCTTGAACATAAGp_1AAAATTATTGATATGTATGAACGAAGTGGTTATTAATAGAGATACAACCAAACGCTTATCTGCCACGTCCGTGACGTCCACACCTTCTCTTGAACATAAGp_2AAAATTATTGATATGTATGAACGAATTTGTTAATAATAGAGATACAACCAAACGCTCATCTGCCACGTCCGAGACGTCCAAACCTTCTCTTGAACATAAGp_3AAAATTATTGATATGTATGAACGAAGTTGTTATTAATAGAGATACAACCAAACGCTTATCTGCCACGTCCGTGACGTCCACACCTTCTCTTGAACATAAGp_4AAAATTATTGATATGTATGAACGAAGTTGTTATTATTAGAGATACAACCAAACGCTTATCTGCCACGTCCGTGACGTCCACACCTTCTCTTGAACATAAG In\u00a0[36]: Copied! <pre># suppress recombination\nmodel = ipcoal.Model(Ne=1000, nsamples=5, recomb=0)\n</pre> # suppress recombination model = ipcoal.Model(Ne=1000, nsamples=5, recomb=0) In\u00a0[37]: Copied! <pre># set a relatively high rate of recombination (equal to mut)\nmodel = ipcoal.Model(Ne=1000, nsamples=5, recomb=1e-8, mut=1e-8)\n</pre> # set a relatively high rate of recombination (equal to mut) model = ipcoal.Model(Ne=1000, nsamples=5, recomb=1e-8, mut=1e-8) In\u00a0[38]: Copied! <pre># define recomb as a Map over 3 intervals from 0-30K\nrate_map = msprime.RateMap(\n    position=[0, 10_000, 20_000, 30_000],\n    rate=[1e-8, 0., 1e-8],\n)\n\n# set the rate_map for recomb\nmodel = ipcoal.Model(nsamples=8, Ne=10_000, recomb=rate_map, store_tree_sequences=True, seed_trees=123, seed_mutations=123)\n\n# when recomb is a RateMap the nsites arg should be None (length is defined by the Map)\nmodel.sim_loci(1, None)\nmodel.draw_tree_sequence(width=800, start=0, max_trees=1000, tip_labels=False, scrollable=True);\n</pre> # define recomb as a Map over 3 intervals from 0-30K rate_map = msprime.RateMap(     position=[0, 10_000, 20_000, 30_000],     rate=[1e-8, 0., 1e-8], )  # set the rate_map for recomb model = ipcoal.Model(nsamples=8, Ne=10_000, recomb=rate_map, store_tree_sequences=True, seed_trees=123, seed_mutations=123)  # when recomb is a RateMap the nsites arg should be None (length is defined by the Map) model.sim_loci(1, None) model.draw_tree_sequence(width=800, start=0, max_trees=1000, tip_labels=False, scrollable=True); 02500050000idx: 0 interval: (0 - 1976) tmrca: 16161.78idx: 1 interval: (1976 - 5329) tmrca: 27856.42idx: 2 interval: (5329 - 5999) tmrca: 30171.99idx: 3 interval: (5999 - 6067) tmrca: 39662.68idx: 4 interval: (6067 - 7085) tmrca: 39662.68idx: 5 interval: (7085 - 8089) tmrca: 39662.68idx: 6 interval: (8089 - 8559) tmrca: 45977.74idx: 7 interval: (8559 - 8969) tmrca: 45977.74idx: 8 interval: (8969 - 20820) tmrca: 45977.74idx: 9 interval: (20820 - 21557) tmrca: 45977.74idx: 10 interval: (21557 - 21678) tmrca: 45977.74idx: 11 interval: (21678 - 22381) tmrca: 35396.8idx: 12 interval: (22381 - 24396) tmrca: 35396.8idx: 13 interval: (24396 - 25052) tmrca: 35396.8idx: 14 interval: (25052 - 26410) tmrca: 15464.09idx: 15 interval: (26410 - 27073) tmrca: 14441.8idx: 16 interval: (27073 - 28901) tmrca: 45977.74idx: 17 interval: (28901 - 30000) tmrca: 45977.74id: 0 pos: 0 time: 1095 mtype: 0id: 1 pos: 1 time: 12349 mtype: 0id: 2 pos: 2 time: 7498 mtype: 0id: 3 pos: 3 time: 8155 mtype: 0id: 4 pos: 4 time: 65 mtype: 0id: 5 pos: 5 time: 492 mtype: 0id: 6 pos: 6 time: 19117 mtype: 0id: 7 pos: 7 time: 23186 mtype: 0id: 8 pos: 8 time: 1736 mtype: 0id: 9 pos: 9 time: 10499 mtype: 0id: 10 pos: 10 time: 13476 mtype: 0id: 11 pos: 11 time: 22181 mtype: 0id: 12 pos: 12 time: 14468 mtype: 0id: 13 pos: 13 time: 20509 mtype: 0id: 14 pos: 14 time: 14238 mtype: 0id: 15 pos: 15 time: 10305 mtype: 0id: 16 pos: 16 time: 21334 mtype: 0id: 17 pos: 17 time: 6564 mtype: 0id: 18 pos: 18 time: 24612 mtype: 0id: 19 pos: 19 time: 13504 mtype: 0id: 20 pos: 20 time: 17480 mtype: 0id: 21 pos: 21 time: 1179 mtype: 0id: 22 pos: 22 time: 7477 mtype: 0id: 23 pos: 23 time: 12222 mtype: 0id: 24 pos: 24 time: 541 mtype: 0id: 25 pos: 25 time: 28858 mtype: 0id: 26 pos: 26 time: 33338 mtype: 0id: 27 pos: 27 time: 13504 mtype: 0id: 28 pos: 28 time: 1148 mtype: 0id: 29 pos: 29 time: 9680 mtype: 0id: 30 pos: 30 time: 12513 mtype: 0id: 31 pos: 31 time: 5331 mtype: 0id: 32 pos: 32 time: 31880 mtype: 0id: 33 pos: 33 time: 25976 mtype: 0id: 34 pos: 34 time: 14041 mtype: 0 In\u00a0[39]: Copied! <pre># default: does not store full TreeSequence objects\nmodel = ipcoal.Model(Ne=10000)\nmodel.sim_trees(2)\nmodel.ts_dict\n</pre> # default: does not store full TreeSequence objects model = ipcoal.Model(Ne=10000) model.sim_trees(2) model.ts_dict Out[39]: <pre>{}</pre> In\u00a0[40]: Copied! <pre># set True: stores TreeSequences in .ts_dict\nmodel = ipcoal.Model(Ne=10000, store_tree_sequences=True)\nmodel.sim_trees(2)\nmodel.ts_dict\n</pre> # set True: stores TreeSequences in .ts_dict model = ipcoal.Model(Ne=10000, store_tree_sequences=True) model.sim_trees(2) model.ts_dict Out[40]: <pre>{0: &lt;tskit.trees.TreeSequence at 0x7ad21c3cbb00&gt;,\n 1: &lt;tskit.trees.TreeSequence at 0x7ad21c2f8320&gt;}</pre>"},{"location":"Model_class/#the-model-class","title":"The Model class\u00b6","text":"<p>ipcoal is an object-oriented library for which the main object users interact with is the <code>Model</code> class. To create a <code>Model</code> you must provide at least one or more parameter arguments to <code>ipcoal.Model()</code> which will return an object that you can store as a variable. This stores the information that defines the population demographic model and substitution model, as well as many other options that can modify how simulations are performed. Simulation methods can be called from this object, in addition to several other methods for visualization and analysis.</p>"},{"location":"Model_class/#demography-tree","title":"Demography (tree)\u00b6","text":"<p>The demographic structure of a population can be defined in ipcoal using the <code>Model</code> class argument tree. The name of this argument is used to indicate that a tree object can be used to define the parameters of a demographic model. These parameters include the topology (relationships) among populations, the divergence times between populations, and the effective population sizes (Ne) of each population.</p>"},{"location":"Model_class/#a-simple-model","title":"A simple Model\u00b6","text":"<p>The simplest demographic model is of a single population with constant Ne, which has no topology or divergence times, and only one Ne parameter. This can be created easily be setting the tree argument to its default value of None. As shown in the second example, you will usually initialize a <code>Model</code> with many additional arguments, which will be described throughout the rest of this document.</p>"},{"location":"Model_class/#using-toytree","title":"Using toytree\u00b6","text":"<p>An example of a more complex model is a species tree topology with 10 lineages, which requires 9 divergence time parameters and 19 Ne parameters. Setting each of these manually, for example by referring to lineages by an integer label, can be very challenging and error-prone. Instead, the approach we use in ipcoal is to create demographic models using <code>ToyTree</code> objects, where it is easy to set data values and visualize them to confirm their accuracy. See the <code>toytree</code> library documentation to learn more about the features for creating and setting data on trees. Here we provide some examples. You can create a tree topology using one of several approaches in <code>toytree</code> which return a <code>ToyTree</code> class object. This includes the random module (<code>toytree.rtree</code>) and the data parsing module (<code>toytree.tree</code>). You can further modify a tree by explicitly setting node heights or edge lengths on it, or by using a number of tree modification functions (<code>toytree.mod</code>), which can be used to do things like stretch or compress edge lengths.</p>"},{"location":"Model_class/#labels-and-units","title":"Labels and units\u00b6","text":"<p>Once your species tree relationships and divergence times are set, you can visualize the tree using its <code>.draw()</code> function call. The edge lengths of a species tree that will be used to define a demographic model should be units of generations. The tips of the tree do not have to align at the present. The tips of the tree will have name labels, whereas internal nodes do not by default, unless set by the user. All nodes have numeric labels which count up from 0 to nnodes-1, in a tips-first then post-order traversal order (see toytree idxorder documentation). The visualization below uses the special tree_style (ts) option type \"p\" to designate a suite of styling arguments that will show the internal numeric labels on nodes, in addition to the tip labels and the vertical scale bar. Here we are drawing the tree that was created above, which has a root height of 1e5 generations.</p>"},{"location":"Model_class/#a-complex-model","title":"A complex model\u00b6","text":"<p>Now that you are sure that the topology and divegence times on your tree are set correctly, you can enter this tree as an argument to initialize a <code>Model</code> object with this defined demography. By default, this will sample one gene copy per lineage (tip) of the species tree, but this can be modified (see <code>nsamples</code>).</p>"},{"location":"Model_class/#effective-population-size-ne","title":"Effective population size (Ne)\u00b6","text":"<p>The effective population size is the key parameter used in population demographic modeling. It determines the probability of coalescence and thus determines the distribution of coalesce times among gene copies in a population. Values of Ne can be set as a constant, or at different values for different populations and ancestral populations in a structured model, such as a species tree.</p>"},{"location":"Model_class/#ne-values-are-diploid","title":"Ne values are diploid\u00b6","text":"<p>By default, in ipcoal Ne represents the number of diploid individuals in a population. Thus, a value of Ne=1000 indicates that there are 2000 haploid gene copies. The coalescent is an approximation of the WrightFisher model, where the probability that any two gene copies share a common ancestor (i.e., coalesce) one generation ago is 1/2N. Because we can model this as an exponentially distributed waiting time, we know that the expected time until the first coalescent event is therefore 2N. Let's verify this by checking that genealogies simulated in a population with Ne=10K have an average time until first coalescence of 20K generations (i.e., 2 times Ne units of generations).</p>"},{"location":"Model_class/#setting-ne","title":"Setting Ne\u00b6","text":"<p>When initializing a <code>Model</code> object you can set Ne using the <code>Ne</code> argument. This accepts argumnets as an integer, float, dictionary, or None. Setting an integer or float will assign this value to all populations in the model. If a dictionary is entered as {lineage: Ne_value, ...} you can set different Ne values to each lineage, selected by name or tree node index. In this case you must enter a key for every population.</p>"},{"location":"Model_class/#setting-ne-on-trees","title":"Setting Ne on trees\u00b6","text":"<p>Finally, another way to set up complex demographic models is to set all data explicitly on the tree object. To use this option you must enter the Ne argument to <code>ipcoal.Model</code> as None. Ne values will then be automatically extracted from the tree input, if present. An error will be raised if all nodes do not have an Ne values set. Note that if an Ne argument (besides None) is entered to <code>ipcoal.Model</code> it will override any Ne values set on a tree. To set Ne data on a tree object we use the <code>set_node_data</code> function in <code>toytree</code>, which can be used to set any abitrary named feature on nodes of a tree. Here the feature name \"Ne\" is special, as ipcoal will look for and recognize it if present. This approach can be more convenient than entering Ne values as a dictionary, like above, because the <code>set_node_data</code> function has some helpful features such as setting a default value to nodes that are not specified, and because the values set to nodes can be easily visualized on trees.</p>"},{"location":"Model_class/#variable-ne-within-intervals","title":"Variable Ne within intervals\u00b6","text":"<p>ipcoal is not currently designed to implement more complex scenarios, such as Ne values that change linearly, or exponentially, from the beginning to the end of an interval. These should be simple enough to implement, but our focus thus far has been primarily on species tree scenarios which have constant Ne within each interval. To set up more complex demographic models I would recommend using <code>msprime</code> for now. If you are interested in helping to implement this please reach out.</p>"},{"location":"Model_class/#sampling-nsamples","title":"Sampling (nsamples)\u00b6","text":"<p>A key feature of the coalescent model, which involves studying the process of evolution backwards in time, is that we do not need to simulate the history of an entire population in order to study its evolution. Instead, we can examine only the history for a set of sampled gene copies in that population. In this way, the number of samples plays an important role in many characteristics of the coalescent. This can be set using the <code>nsamples</code> argument to <code>ipcoal.Model</code>. This can be entered as an integer, which sets the number of gene copies to sample from every population, or as a dict, where different numbers of gene copies can be sampled from each population. Here, a sample represents a haploid gene copy. Note that it is still possible to simulate diploid sequences in ipcoal by sampling an even number of samples in each population. The implementation of joining pairs of samples into diploids only takes place within downstream analyses, such as writing sequences. To demonstrate the <code>nsamples</code> argument we show several examples of initialized <code>Model</code> objects below, where we show the imap dictionary of each, which maps population names to lists of sample names.</p>"},{"location":"Model_class/#gene-flow-admixture_edges","title":"Gene flow (admixture_edges)\u00b6","text":"<p>In both ipcoal and toytree you can define an admixture event with one or more 4-part tuples. This designates the (source, destination, time, rate/prop). If the time is a single value then an admixture event occurs by transferring a proportion of one population to another; whereas if time is entered as a tuple of (time_min, time_max) it occurs as a migration rate over this period of time. In simulations you will need to provide all four arguments, but for tree drawings you only need to provide the first two and the latter two will be automated to make it look nice. So let\u2019s try first to draw an admixture edge on a tree.</p> <p>This is done by supplying the event tuple to the <code>admixture_edges</code> tree drawing argument. Here the source and destination refer to the index (idx) numeric labels of each node (which you find by drawing the tree). You can see that the admixture edge is not simply a horizontal line, but it follows the edges towards the tips of the source node and towards the ancestors from the destination node. This is to make the direction of inheritance of the introgression clear. In this case, a tuple of (1, 2) indicates that introgression occurs from 1 to 2 backwards in time; meaning that some alleles that arose in the ancestor of node 2 have introgressed into lineage 1 at the present.</p>"},{"location":"Model_class/#admixture","title":"Admixture\u00b6","text":"<p>Now let\u2019s define an admixture event to a <code>Model</code> object. The proportion here is set to 0.1 (10% admixture). The timing of the event can be entered either as a integer, representing the time in generations at which it occurs, or as a float, in which case the timing will be modeled as occuring at the set percentage of the way back in time along the time at which the two edges both existed. The latter argument is useful for some automation scenarios so you do not need to find when two edges coexisted in time. Both are demonstrated below. In the first case I added a red line at t=20K gens to highlight that the coalescent times of introgressed trees occur at least 20K generations back, as expected.</p>"},{"location":"Model_class/#migration","title":"Migration\u00b6","text":"<p>Next is an example where we model a migration instead of an admixture event. The difference is that instead of an instantaneous mixing event, we model a migration rate from one population to another over a period of time. Similar to above, the period of time can be set as a distinct start and end time as integer generations, or it can be set as a float between (0-1) to indicate the proportion of time along their shared time interval. Both are demonstrated below.</p>"},{"location":"Model_class/#mut-mutation-rate","title":"mut (mutation rate)\u00b6","text":"<p>The mutation rate is defined in units of mutations per site per generation. This can be entered as a float value or as a Map which sets a different rate for different intervals of a genome. The mutation rate defines the probability of mutation events over the length of a simulation. The outcome of these events is a consequence of the substitution model, which defines the number of states and their transition rates.</p>"},{"location":"Model_class/#mutation-ratemap","title":"Mutation RateMap\u00b6","text":"<p>The mutation rate can also be set to vary over different intervals of a chromosome by using an <code>msprime.RateMap</code> object to define the mutation rate. This take N args to define the start and end positions of intervals, and N-1 rate args. In the example below we simulate a 30Kb locus with zero mutations in the first 1/3, a low mutation rate in the middle 1/3, and high mutation rate on the last 1/3. You can see that conditional on the different lengths of the intervals covered by each genealogy in the simulated tree sequence below, many more mutations occurred on the genealogies associated with the latter half of the chromosome.</p>"},{"location":"Model_class/#subst_model","title":"subst_model\u00b6","text":"<p>The <code>subst_model</code> arg defines the <code>msprime.MutationModel</code> underlying the simulation of mutations. See the msprime/tskit mutation simulation documentation for a detailed description. Here we provide some simple examples. The default mutation model is Jukes-Cantor 1969 with equal rates and equilibrium frequencies for A,C,G,T. More complex models such as HKY and GTR can be created as custom parameterized models using <code>msprime.MutationModel</code> as shown below. Similarly, other models can be defined that use a custom set of states and transition rates, such as the pam and binary models shown below.</p>"},{"location":"Model_class/#recomb-recombination-rate","title":"recomb (recombination rate)\u00b6","text":"<p>The recombination rate can be set as a float value or a RateMap similar to the mutation rate. It affects the per-site per-generation rate of recombination. To suppress recombination so that all sites within a locus share the same genealogical history you can set <code>recomb=0</code>. The absolute value of the recombination rate is often examined relative to the mutation rate.</p>"},{"location":"Model_class/#recombination-ratemap","title":"Recombination RateMap\u00b6","text":"<p>Recombination can be set as a Map that varies over different regions of a chromosome. This can be used to represent an inversion where recombination is suppressed, or variation in recombination associated with hotpots or centromeres. In the example below we suppress recombination over the middle 1/3 of the chromosome. As a consequence, you can see that a single tree represents the ancestry over the entire center of the chromosome and accumulates many substitutions to support it.</p>"},{"location":"Model_class/#seed_trees","title":"seed_trees\u00b6","text":"<p>This sets a numpy random number generator (RNG) to be used to stochastically sample coalescent times during a simulation.</p>"},{"location":"Model_class/#seed_mutations","title":"seed_mutations\u00b6","text":"<p>This sets a numpy random number generator (RNG) to be used to stochastically simulate the mutation process during a simulation.</p>"},{"location":"Model_class/#store_tree_sequences","title":"store_tree_sequences\u00b6","text":"<p>By default ipcoal does not store TreeSequence objects. These are very data rich objects that consume a lot of memory, and so if you don't plan to interact with them there is no need to save it. Instead, ipcoal.Model objects always parse a summary of the simulation that is stored in its .df and .seqs attributes. However, if you choose to store the tree sequences it enables further types of analyses and visualizations in ipcoal or by interacting with TreeSequences from within the Model's <code>ts_dict</code> dictionary.</p>"},{"location":"Model_class/#kwargs","title":"**kwargs\u00b6","text":"<p>Most other arguments supported by <code>msprime.sim_ancestry</code> or <code>msprime.sim_mutations</code> are supported by the Model class. Examples include <code>ancestry_model</code>, <code>discrete_genomes</code>, <code>record_full_arg</code>, etc.</p>"},{"location":"SMC_likelihood/","title":"SMC likelihood","text":"In\u00a0[11]: Copied! <pre>import ipcoal\nfrom ipcoal.smc.src.utils import *\n</pre> import ipcoal from ipcoal.smc.src.utils import * In\u00a0[28]: Copied! <pre># dist, dist, tree, tree\ndtree, dtopo, gidxs, tidxs = get_ms_smc_data_from_model(model)\n</pre> # dist, dist, tree, tree dtree, dtopo, gidxs, tidxs = get_ms_smc_data_from_model(model) In\u00a0[29]: Copied! <pre># should return interval lengths too\nS, G, I = get_test_data()\n</pre> # should return interval lengths too S, G, I = get_test_data() In\u00a0[32]: Copied! <pre># ...\ntree_spans, topo_spans, topo_idxs, gtrees = get_waiting_distance_data_from_model(model)\n</pre> # ... tree_spans, topo_spans, topo_idxs, gtrees = get_waiting_distance_data_from_model(model) In\u00a0[\u00a0]: Copied! <pre># example dataset\nS, G, I, DISTS, GMASK, TMASK = ipcoal.smc.get_test_data(nloci=1, nsites=1e5)\n</pre> # example dataset S, G, I, DISTS, GMASK, TMASK = ipcoal.smc.get_test_data(nloci=1, nsites=1e5) <p>How does the idxs arg work? Does it combine lengths together between the masks?</p> In\u00a0[\u00a0]: Copied! <pre>ipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0)\nipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0, idxs=GMASK)\nipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0, idxs=TMASK)\n</pre> ipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0) ipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0, idxs=GMASK) ipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0, idxs=TMASK) In\u00a0[\u00a0]: Copied! <pre># get example dataset ipcoal.Model\nmodel = ipcoal.msc.get_test_model()\n\n# simulate an ARG\nmodel.sim_trees(nloci=1, nsites=1e5)\n\n# organize data into S, G, I, X\nS = model.tree\nG = model.df.genealogy\nI = model.get_imap_dict()\nX = model.df.nbps\n</pre> # get example dataset ipcoal.Model model = ipcoal.msc.get_test_model()  # simulate an ARG model.sim_trees(nloci=1, nsites=1e5)  # organize data into S, G, I, X S = model.tree G = model.df.genealogy I = model.get_imap_dict() X = model.df.nbps In\u00a0[\u00a0]: Copied! <pre>ipcoal.smc.TreeEmbedding(S, G, I,\n</pre> ipcoal.smc.TreeEmbedding(S, G, I,  In\u00a0[\u00a0]: Copied! <pre># get likelihood of G | S\nipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0)\n</pre> # get likelihood of G | S ipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0) Out[\u00a0]: <pre>1513.7757929783581</pre> In\u00a0[9]: Copied! <pre># get likelihood of G | S\nipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0)\n</pre> # get likelihood of G | S ipcoal.smc.get_ms_smc_loglik(S, G, I, recombination_rate=2e-9, lengths=X, event_type=0) Out[9]: <pre>1513.7757929783581</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[3]: Copied! <pre># get (S, G, I) for an example dataset\nS, G, I = ipcoal.msc.get_test_data(nloci=100, nsites=1, seed=123)\n</pre> # get (S, G, I) for an example dataset S, G, I = ipcoal.msc.get_test_data(nloci=100, nsites=1, seed=123) In\u00a0[4]: Copied! <pre># draw the first genealogy embedded\nipcoal.draw.draw_embedded_genealogy(S, G[0], I);\n</pre> # draw the first genealogy embedded ipcoal.draw.draw_embedded_genealogy(S, G[0], I); idx=5 Ne=1e+05 Tc=1 Tg=2e+05idx=3 Ne=1e+05 Tc=3 Tg=6e+05idx=4 Ne=1e+05 Tc=1 Tg=2e+05idx=2 Ne=1e+05 Tc=2 Tg=4e+05idx=0 Ne=1e+05 Tc=1 Tg=2e+05idx=1 Ne=1e+05 Tc=1 Tg=2e+05idx=6 Ne=1e+05 Tc=0 Tg=0A_0A_2A_1B_0B_1C_0D_0node=0node=1node=2node=7node=3node=4node=8node=5node=6node=9node=10node=11node=120250000500000750000 <p>In this case, the species tree contains all of the information to describe a demographic model. This includes the topology for lineages A, B, C, and D, their divergence times, and an effective population size parameter for each species tree interval. These data are stored in the ToyTree object as node data.</p> In\u00a0[5]: Copied! <pre># show the species tree data\nS.get_node_data([\"idx\", \"name\", \"height\", \"Ne\"])\n</pre> # show the species tree data S.get_node_data([\"idx\", \"name\", \"height\", \"Ne\"]) Out[5]: idx name height Ne 0 0 A 0.0 100000 1 1 B 0.0 100000 2 2 C 0.0 100000 3 3 D 0.0 100000 4 4 200000.0 100000 5 5 400000.0 100000 6 6 600000.0 100000 <p>The genealogy embedding table contains the information of how a genealogy fits into a species tree container. Our goal is to calculate the likelihood of observing this genealogy given the species tree parameters. Thus, we need to calculate the probability of coalescence at each unit of time. Fortunately, this problem is simplified by recognizing that these probabilities are constant within some intervals of time. In other words, the probability of coalescent is piece-wise constant. Knowing this, we can separate out these intervals where it is constant and compute the probabilities just within each one.</p> <p>The probability of coalescence is calculated following the Kingman coalscent for k samples as $\\frac{k(k - 1)}{4N}$. This is a product of the rate of coalescence given the effective population size in that interval $\\frac{1}{2N}$, and the combinatorial number of ways that 2 samples could have coalesced given k samples in that interval $\\frac{k(k-1)}{2}$. Thus, the probability of a coalescence event is greater when k is larger, and when $N_e$ is smaller.</p> In\u00a0[6]: Copied! <pre># get embedding table for the first genealogy\nipcoal.msc.get_genealogy_embedding_table(S, G[0], I)\n</pre> # get embedding table for the first genealogy ipcoal.msc.get_genealogy_embedding_table(S, G[0], I) Out[6]: start stop st_node neff nedges dist gidx edges 0 0.000000 8.348442e+04 0 100000.0 3 8.348442e+04 0 [0, 1, 2] 1 83484.416529 2.000000e+05 0 100000.0 2 1.165156e+05 0 [2, 7] 2 0.000000 6.205383e+04 1 100000.0 2 6.205383e+04 0 [3, 4] 3 62053.832461 2.000000e+05 1 100000.0 1 1.379462e+05 0 [8] 4 0.000000 4.000000e+05 2 100000.0 1 4.000000e+05 0 [5] 5 0.000000 6.000000e+05 3 100000.0 1 6.000000e+05 0 [6] 6 200000.000000 2.838717e+05 4 100000.0 3 8.387172e+04 0 [2, 7, 8] 7 283871.722216 4.000000e+05 4 100000.0 2 1.161283e+05 0 [7, 9] 8 400000.000000 4.257337e+05 5 100000.0 3 2.573368e+04 0 [5, 7, 9] 9 425733.683785 6.000000e+05 5 100000.0 2 1.742663e+05 0 [5, 10] 10 600000.000000 7.091705e+05 6 100000.0 3 1.091705e+05 0 [5, 6, 10] 11 709170.541694 7.423249e+05 6 100000.0 2 3.315435e+04 0 [10, 11] 12 742324.888479 inf 6 100000.0 1 inf 0 [12] <p>Each interval of the table delimits a gene tree node (coalescence) or species tree node (interval breakpoint). Each lists its <code>start</code> and <code>stop</code> time (in generations), the species tree node ID (<code>st_node</code>), effective population size (<code>neff</code>, i.e., $N_e$), number of genealogy edges in that interval (<code>nedges</code>; i.e., $k$), and the interval length (<code>stop</code> - <code>start</code>). From this we have all the information needed to compute the probability of coalescence.</p> <p>To compute the likelihood of our observation, we model each coalescent event as a exponential waiting time given the rate of coalescence. For each species tree interval, we also must compute the likelihood that no coalescence occurs during the remaining end of the interval. This set of calculations is the multispecies coalescent (MSC) likelihood. Below we describe some ways it is implemented.</p> In\u00a0[7]: Copied! <pre># log-likelihood of 100 unlinked genealogies\nipcoal.msc.get_msc_loglik(S, G, I)\n</pre> # log-likelihood of 100 unlinked genealogies ipcoal.msc.get_msc_loglik(S, G, I) Out[7]: <pre>7973.467153781378</pre> <p>Note, this function is generally intended for educational purposes. It is easy to use and understand as it takes the data objects (S, G, I) directly and returns a value. However, in practice users will want to use the much faster implementation below. For comparision, we show the speed for this implementation in the cell below.</p> In\u00a0[8]: Copied! <pre>%%timeit\nipcoal.msc.get_msc_loglik(S, G, I)\n</pre> %%timeit ipcoal.msc.get_msc_loglik(S, G, I) <pre>51.8 ms \u00b1 12.8 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</pre> In\u00a0[9]: Copied! <pre># get the embedding and encoding as separate arrays\na0, a1 = ipcoal.msc.get_genealogy_embedding_arrays(S, G, I)\n</pre>  # get the embedding and encoding as separate arrays a0, a1 = ipcoal.msc.get_genealogy_embedding_arrays(S, G, I) In\u00a0[10]: Copied! <pre># log-likelihood of 100 unlinked genealogies\nipcoal.msc.get_msc_loglik_from_embedding(a0)\n</pre> # log-likelihood of 100 unlinked genealogies ipcoal.msc.get_msc_loglik_from_embedding(a0) Out[10]: <pre>7973.467153781378</pre> In\u00a0[11]: Copied! <pre>%%timeit\nipcoal.msc.get_msc_loglik_from_embedding(a0)\n</pre> %%timeit ipcoal.msc.get_msc_loglik_from_embedding(a0) <pre>165 \u03bcs \u00b1 14.4 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[12]: Copied! <pre># [todo] show example of changing Ne for optimization\n</pre> # [todo] show example of changing Ne for optimization In\u00a0[13]: Copied! <pre># [todo] show example using the dists argument of `get_msc_loglik_from_embedding`.\n</pre> # [todo] show example using the dists argument of `get_msc_loglik_from_embedding`. In\u00a0[14]: Copied! <pre># to get the example species tree, genealogy, and mapping data\nipcoal.msc.get_test_data()\n</pre> # to get the example species tree, genealogy, and mapping data ipcoal.msc.get_test_data() Out[14]: <pre>(&lt;toytree.ToyTree at 0x724a8c7a8770&gt;,\n &lt;toytree.ToyTree at 0x724a8cdad760&gt;,\n {'A': ['0', '1', '2'], 'B': ['3', '4'], 'C': ['5'], 'D': ['6']})</pre> <p>You can optionally select the number of simulated genealogies using <code>nloci</code>. By default their lengths are each 1, such that the simulated genealogies are unlinked, but you can set <code>nsites</code> to make them into longer treesequences. Under the hood this will initialize an <code>ipcoal.Model</code> object using the example species tree and all other arguments at defaults. It will then call <code>Model.sim_trees</code> using the <code>nloci</code> and <code>nsites</code> args. This is primarily used for setting up simple tests.</p> In\u00a0[15]: Copied! <pre># to simulate multiple loci, or longer loci, using the example dataset\nipcoal.msc.get_test_data(nloci=2, nsites=100, seed=123)\n</pre> # to simulate multiple loci, or longer loci, using the example dataset ipcoal.msc.get_test_data(nloci=2, nsites=100, seed=123) Out[15]: <pre>(&lt;toytree.ToyTree at 0x724a8c88a9f0&gt;,\n [&lt;toytree.ToyTree at 0x724a8cdada00&gt;, &lt;toytree.ToyTree at 0x724a8c88ae10&gt;],\n {'A': ['A_0', 'A_1', 'A_2'], 'B': ['B_0', 'B_1'], 'C': ['C_0'], 'D': ['D_0']})</pre> In\u00a0[16]: Copied! <pre>ipcoal.msc.get_test_model()\n</pre> ipcoal.msc.get_test_model() Out[16]: <pre>&lt;ipcoal.model.Model at 0x724a8c888e30&gt;</pre> In\u00a0[17]: Copied! <pre># overrides Ne and nsamples to return a genealogy and imap from S\ng, i = ipcoal.msc.get_embedded_genealogy(S, Ne=2e5, nsamples=2, seed_trees=1234)\n# draw the genealogy embedded in S\nipcoal.draw.draw_embedded_genealogy(S, g, i);\n</pre> # overrides Ne and nsamples to return a genealogy and imap from S g, i = ipcoal.msc.get_embedded_genealogy(S, Ne=2e5, nsamples=2, seed_trees=1234) # draw the genealogy embedded in S ipcoal.draw.draw_embedded_genealogy(S, g, i); idx=5 Ne=1e+05 Tc=1 Tg=2e+05idx=3 Ne=1e+05 Tc=3 Tg=6e+05idx=4 Ne=1e+05 Tc=1 Tg=2e+05idx=2 Ne=1e+05 Tc=2 Tg=4e+05idx=0 Ne=1e+05 Tc=1 Tg=2e+05idx=1 Ne=1e+05 Tc=1 Tg=2e+05idx=6 Ne=1e+05 Tc=0 Tg=0A_0A_1B_1B_0C_0C_1D_0D_1node=1node=2node=0node=5node=6node=7node=11node=3node=4node=10node=8node=9node=12node=13node=1404000008000001200000 In\u00a0[18]: Copied! <pre>ipcoal.msc.get_genealogy_embedding_table(S, G[0], I).shape\n</pre> ipcoal.msc.get_genealogy_embedding_table(S, G[0], I).shape Out[18]: <pre>(13, 8)</pre> In\u00a0[19]: Copied! <pre>ipcoal.msc.get_genealogy_embedding_table(S, G, I).shape\n</pre> ipcoal.msc.get_genealogy_embedding_table(S, G, I).shape Out[19]: <pre>(1300, 8)</pre> In\u00a0[20]: Copied! <pre>arr, _ = ipcoal.msc.get_genealogy_embedding_arrays(S, G, I)\narr.shape\n</pre> arr, _ = ipcoal.msc.get_genealogy_embedding_arrays(S, G, I) arr.shape Out[20]: <pre>(100, 13, 7)</pre>"},{"location":"SMC_likelihood/#sequentially-markov-coalescent-likelihood","title":"Sequentially Markov Coalescent Likelihood\u00b6","text":"<p>The Sequentially Markov Coalescent (SMC) can be used to calculate the likelihood of the waiting distance between recombination events across the length of a chromosome. The Multispecies Sequentially Markov Coalescent (MS-SMC) extends this calculation to the likelihood of the waiting distance between multiple types of recombination events across a chromosome, given a parameterized species tree. These event types include (1) any recombination event; (2) a recombination event causing a change to a coalescent time in a genealogy (tree-change); and (3) a recombination event causing a change to the topology of a genealogy (topology-change).</p> <p>Here we demonstrate several methods in the <code>ipcoal.smc</code> package for applying SMC calculations to linked genealogical trees in a tree sequence.</p>"},{"location":"SMC_likelihood/#tldr","title":"tldr;\u00b6","text":"<p>The likelihood of the waiting distances in a treesequence can be calculated using <code>get_smc_loglik</code>.</p>"},{"location":"SMC_likelihood/#test-dataset","title":"Test dataset\u00b6","text":"<p>A MSC data set is composed of a species tree (demographic model), one or more genealogies that can be embedded in that species tree, and an imap dictionary that maps species tree tip names to genealogy tip names. We can generate a simple test dataset for studying the MSC model using <code>msc.get_test_data</code>. This returns a species tree (S), a collection of embedded genealogies (G), and a mapping dictionary (I). These are described further below.</p>"},{"location":"SMC_likelihood/#genealogy-embedding-table","title":"Genealogy embedding table\u00b6","text":"<p>The first step of a multispecies coalescent analysis involves decomposing the data (S, G, I) into a table. Let's start with our example test dataset. This includes a species tree (S) composing four lineages and collection of genealogies (G) each composing seven samples. Each genealogy has 3 samples from lineage A, 2 from lineage B, and 1 from C and D. This is described in the mapping dictionary (I), which maps species names to lists of genealogy tip names. We can pass these three variables to the function <code>draw_embedded_genealogy</code> to create a visualization of the genealogy embedding for the first genealogy.</p>"},{"location":"SMC_likelihood/#calculate-msc-likelihood","title":"Calculate MSC likelihood\u00b6","text":"<p>The function <code>get_msc_loglik</code> returns the summed log-likelihood of all trees in G, given the model S, and their mapping in I.</p>"},{"location":"SMC_likelihood/#faster-implementations","title":"Faster implementations\u00b6","text":"<p>A much faster implementation is also provided in <code>get_msc_loglik_from_embedding</code>. This makes use of the <code>numba</code> library to perform just-in-time compilation. This is a workaround for writing very fast Python code that runs at a similar speed to compiled languages like C. To use this method you should first generate the genealogy embedding data as a numpy float array like below, and then pass the array to the likelihood function. You can see from the <code>%%timeit</code> call below which measures the running time for the cell, that this implementation runs about &gt;250X faster.</p>"},{"location":"SMC_likelihood/#parameter-optimization","title":"Parameter optimization\u00b6","text":"<p>The problem of parameter optimization is outside of the scope of this documentation, as there are many approaches. These typically fall into the categories of either Maximum Likelihood or Bayesian MCMC. In either case, we must propose a set of parameters, calculate the likelihood, and then propose a different set of parameters based on some proposal mechanism, and either accept or reject the new parameter set based on some acceptance criterion.</p> <p>Note that some types of proposals are very easy to implement, such as proposing different Ne values which requires only changing their value in the embedding array; while other types of moves require greater effort, such as proposing a different divergence time value, which can require re-embedding the genealogies (i.e., re-creating the embedding arrays). Efficient algorithms can be written for the latter, but we have not put great effort into this yet.</p>"},{"location":"SMC_likelihood/#linked-trees","title":"Linked trees\u00b6","text":"<p>While the MSC model was originally developed to describe an unlinked distribution of trees, it can also be applied to a sample of linked trees. In this case the key difference is that each tree is not treated equally. Instead, trees should be weighted relative to their contribution to the data being studied. ...</p>"},{"location":"SMC_likelihood/#utilities","title":"Utilities\u00b6","text":"<p>Here we provide a short description of several functions available from the <code>ipcoal.msc</code> subpackage.</p>"},{"location":"SMC_likelihood/#get_test_data","title":"get_test_data\u00b6","text":"<p>This returns an example dataset composed of a species tree (ToyTree), gene tree (ToyTree), and imap dictionary (dict). The species tree describes a 4-tip imbalanced tree <code>(((A,B),C),D);</code> with equal spaced internodes and a root height of 1e6 generations. Each species tree interval has Ne=1e5. Each genealogy samples 3 tips from 'A', 2 from 'B', and 1 from 'C' and 'D'.</p>"},{"location":"SMC_likelihood/#get_test_model","title":"get_test_model\u00b6","text":"<p>This returns an <code>ipcoal.Model</code> object initialized with the example 4-tip species tree model from <code>get_test_data</code>. This is primarily used for testing.</p>"},{"location":"SMC_likelihood/#get_embedded_genealogy","title":"get_embedded_genealogy\u00b6","text":"<p>This is a convenience function to initialize an <code>ipcoal.Model</code> as <code>ipcoal.Model(tree=S, **kwargs)</code> where you can pass additional kwargs to initialize the model (such as nsamples). It then calls <code>sim_trees</code> to simulate and return one genealogy and an imap dict. One example usage for this is that you have a species tree and just want to sample one or more random genealogies to embed and visualize in one simple step, like below.</p>"},{"location":"SMC_likelihood/#get_genealogy_embedding_table","title":"get_genealogy_embedding_table\u00b6","text":"<p>The genealogy embedding table is returned as a <code>pandas.DataFrame</code>. This is easy to read and interpret. If you enter a single genealogy then the returned table will be composed only the intervals in that genealogy, but if you enter multiple genealogies then each is listed sequentially in the table, labeled by a different genealogy index (gidx column).</p>"},{"location":"SMC_likelihood/#get_genealogy_embedding_arrays","title":"get_genealogy_embedding_arrays\u00b6","text":"<p>The genealogy embedding array is similar to the genealogy embedding table, just formatted differently. It is less user-friendly to read and interpret, but much faster for operations, and so this is what is generally used under the hood. It separates the first 7 columns of the genealogy embedding table from a second array which contains info on which edges are represented in each interval. The latter array is not needed for MSC calculations. In contrast to the 2D genealogy embedding table, the genealogy embedding array is 3D (ntrees, nrows, ncolumns), storing each genealogy as a separate 2D embedding array.</p>"},{"location":"change_log/","title":"Change log","text":"<p>The changelog will be updated on each packaged release beginning with  <code>ipcoal</code> v.1.0. Please see the GitHub repo for more detailed commit  messages and the history prior to v.1.0.</p>"},{"location":"change_log/#2024418-v100","title":"2024/4/18 (v.1.0.0)","text":"<ul> <li>update to version 1.0</li> </ul>"},{"location":"citation/","title":"Citation","text":""},{"location":"citation/#how-to-cite","title":"How to cite","text":"<p>Please cite the following paper when using ipcoal:</p> <ul> <li>McKenzie PF, Eaton DAR. ipcoal: an interactive Python package for simulating and analyzing genealogies and sequences on a species tree or network.  Bioinformatics. 2020 Aug 15;36(14):4193-4196.  doi: 10.1093/bioinformatics/btaa486 PMID: 32399564.</li> </ul> <p>If you use ipcoal to perform coalescent simulations please also cite the  following:</p> <ul> <li>Baumdicker, Franz, Gertjan Bisschop, Daniel Goldstein, Graham Gower, Aaron P  Ragsdale, Georgia Tsambos, Sha Zhu, et al. 2022. \u201cEfficient Ancestry and Mutation Simulation with Msprime 1.0.\u201d Genetics 220 (3): iyab229.  https://doi.org/10.1093/genetics/iyab229.</li> </ul>"},{"location":"citation/#bibtex","title":"Bibtex","text":"<p>These references are also available in bibtex format below. <pre><code>@article{mckenzie_ipcoal_2020,\n    title = {ipcoal: an interactive {Python} package for simulating and analyzing genealogies and sequences on a species tree or network},\n    shorttitle = {ipcoal},\n    url = {https://academic.oup.com/bioinformatics/article/doi/10.1093/bioinformatics/btaa486/5836496},\n    doi = {10.1093/bioinformatics/btaa486},\n    language = {en},\n    urldate = {2020-07-14},\n    journal = {Bioinformatics},\n    author = {McKenzie, Patrick F. and Eaton, Deren A. R.},\n    year = {2020},\n}\n\n@article{baumdicker_efficient_2022,\n    title = {Efficient ancestry and mutation simulation with msprime 1.0},\n    volume = {220},\n    issn = {1943-2631},\n    url = {https://doi.org/10.1093/genetics/iyab229},\n    doi = {10.1093/genetics/iyab229},\n    abstract = {Stochastic simulation is a key tool in population genetics, since the models involved are often analytically intractable and simulation is usually the only way of obtaining ground-truth data to evaluate inferences. Because of this, a large number of specialized simulation programs have been developed, each filling a particular niche, but with largely overlapping functionality and a substantial duplication of effort. Here, we introduce msprime version 1.0, which efficiently implements ancestry and mutation simulations based on the succinct tree sequence data structure and the tskit library. We summarize msprime\u2019s many features, and show that its performance is excellent, often many times faster and more memory efficient than specialized alternatives. These high-performance features have been thoroughly tested and validated, and built using a collaborative, open source development model, which reduces duplication of effort and promotes software quality via community engagement.},\n    number = {3},\n    urldate = {2022-05-06},\n    journal = {Genetics},\n    author = {Baumdicker, Franz and Bisschop, Gertjan and Goldstein, Daniel and Gower, Graham and Ragsdale, Aaron P and Tsambos, Georgia and Zhu, Sha and Eldon, Bjarki and Ellerman, E Castedo and Galloway, Jared G and Gladstein, Ariella L and Gorjanc, Gregor and Guo, Bing and Jeffery, Ben and Kretzschumar, Warren W and Lohse, Konrad and Matschiner, Michael and Nelson, Dominic and Pope, Nathaniel S and Quinto-Cort\u00e9s, Consuelo D and Rodrigues, Murillo F and Saunack, Kumar and Sellinger, Thibaut and Thornton, Kevin and van Kemenade, Hugo and Wohns, Anthony W and Wong, Yan and Gravel, Simon and Kern, Andrew D and Koskela, Jere and Ralph, Peter L and Kelleher, Jerome},\n    month = mar,\n    year = {2022},\n    pages = {iyab229},\n    file = {Full Text PDF:/home/deren/Zotero/storage/AA8Y5CAC/Baumdicker et al. - 2022 - Efficient ancestry and mutation simulation with ms.pdf:application/pdf;Snapshot:/home/deren/Zotero/storage/CHWW2J2J/6460344.html:text/html},\n}\n</code></pre></p>"},{"location":"contribute/","title":"Contributing","text":"<p>Collaborator's are very welcome!</p> <p>If you haven\u2019t already, you\u2019ll want to first get familiar with the <code>ipcoal</code> repository at http://github.com/eaton-lab/ipcoal.  There you will find the source code and issue tracker where you can inquire about ongoing development, discuss planned contributions, and volunteer to take on known issues or future planned developments.</p>"},{"location":"contribute/#getting-started","title":"Getting started","text":"<p>To contribute as a developer you'll need to install <code>ipcoal</code> from source from GitHub and install additional dependencies used for testing the code. Our workflow for this is to clone the repository (in your case, a fork of the repo) and install in development mode using pip.</p> <pre><code># install dependencies from conda\n$ conda install ipcoal -c eaton-lab --only-deps\n\n# clone the repo and cd into it\n$ git clone https://github.com/eaton-lab/ipcoal.git\n$ cd ipcoal/\n\n# call pip install in 'development mode' (note the '-e .')\n$ pip install -e . --no-deps\n</code></pre>"},{"location":"gene-tree-inference/","title":"Gene tree inference","text":"In\u00a0[114]: Copied! <pre>import ipcoal\nimport toytree\nimport msprime\nimport numpy as np\n</pre> import ipcoal import toytree import msprime import numpy as np In\u00a0[3]: Copied! <pre># ipcoal.phylo.infer_raxml_ng_tree\n# ipcoal.phylo.infer_raxml_ng_trees\n</pre> # ipcoal.phylo.infer_raxml_ng_tree # ipcoal.phylo.infer_raxml_ng_trees In\u00a0[4]: Copied! <pre># simulate sequences for two populations\nmodel = ipcoal.Model(\"(a:50000,b:50000);\", Ne=20000, nsamples=8, recomb=0, seed_mutations=123, seed_trees=123)\nmodel.sim_loci(nloci=10, nsites=10000)\n</pre> # simulate sequences for two populations model = ipcoal.Model(\"(a:50000,b:50000);\", Ne=20000, nsamples=8, recomb=0, seed_mutations=123, seed_trees=123) model.sim_loci(nloci=10, nsites=10000) In\u00a0[5]: Copied! <pre># infer a gene tree for loci 0-5 concatenated and draw the gtree\ngtree = ipcoal.phylo.infer_raxml_ng_tree(model, idxs=[0, 1, 2, 3, 4], diploid=True, nboots=100)\ngtree.mod.root_on_minimal_ancestor_deviation(inplace=True)\ngtree.draw(ts='b', scale_bar=True, label=\"concat loci 0-5\");\n</pre> # infer a gene tree for loci 0-5 concatenated and draw the gtree gtree = ipcoal.phylo.infer_raxml_ng_tree(model, idxs=[0, 1, 2, 3, 4], diploid=True, nboots=100) gtree.mod.root_on_minimal_ancestor_deviation(inplace=True) gtree.draw(ts='b', scale_bar=True, label=\"concat loci 0-5\"); b_1b_3b_0b_2a_3a_1a_0a_20.000750.00050.000250concat loci 0-5 In\u00a0[6]: Copied! <pre># infer gene trees separately for loci 0-5 as a dataframe\ngtdf = ipcoal.phylo.infer_raxml_ng_trees(model, idxs=range(5), diploid=True, nboots=100)\ngtdf\n</pre> # infer gene trees separately for loci 0-5 as a dataframe gtdf = ipcoal.phylo.infer_raxml_ng_trees(model, idxs=range(5), diploid=True, nboots=100) gtdf Out[6]: locus start end nbps nsnps gene_tree 0 0 0 10000 10000 74 ((b_3:1e-06,(b_0:1e-06,b... 1 1 0 10000 10000 34 (a_3:1e-06,a_0:1e-06,((a... 2 2 0 10000 10000 24 (b_1:1e-06,b_0:1e-06,(b_... 3 3 0 10000 10000 38 ((b_0:1e-06,(b_3:0.0003,... 4 4 0 10000 10000 40 (b_2:1e-06,b_1:0.000899,... In\u00a0[7]: Copied! <pre># a phylip string\nphy = \"\"\"\\\n4 10\nA ACAACCGGTT\nB ACATCCGGAA\nC CCATCCGGAT\nD AACACCGGTT\n\"\"\"\n\n# call raxml-ng on phylip str and draw result ToyTree\ntree = ipcoal.phylo.infer_raxml_ng_tree_from_alignment(phy)\ntree.draw();\n</pre> # a phylip string phy = \"\"\"\\ 4 10 A ACAACCGGTT B ACATCCGGAA C CCATCCGGAT D AACACCGGTT \"\"\"  # call raxml-ng on phylip str and draw result ToyTree tree = ipcoal.phylo.infer_raxml_ng_tree_from_alignment(phy) tree.draw(); ADBC In\u00a0[8]: Copied! <pre># concatenate loci 2-4 and infer gene tree\ntree = ipcoal.phylo.infer_raxml_ng_tree(model, idxs=[2, 3, 4], diploid=True)\ntree.draw(scale_bar=True);\n</pre> # concatenate loci 2-4 and infer gene tree tree = ipcoal.phylo.infer_raxml_ng_tree(model, idxs=[2, 3, 4], diploid=True) tree.draw(scale_bar=True); b_2b_3b_1a_1a_3a_0a_2b_00.00120.00080.00040 In\u00a0[9]: Copied! <pre># return a pandas Dataframe w/ trees and stats\nipcoal.phylo.infer_raxml_ng_trees(model, diploid=True, nthreads=2, nworkers=1, nproc=5)\n</pre> # return a pandas Dataframe w/ trees and stats ipcoal.phylo.infer_raxml_ng_trees(model, diploid=True, nthreads=2, nworkers=1, nproc=5) Out[9]: locus start end nbps nsnps gene_tree 0 0 0 10000 10000 74 (a_3:1e-06,a_0:0.000398,... 1 1 0 10000 10000 34 ((b_3:1e-06,b_1:1e-06):0... 2 2 0 10000 10000 24 (b_2:1e-06,(b_1:1e-06,b_... 3 3 0 10000 10000 38 (a_3:1e-06,a_2:1e-06,a_0... 4 4 0 10000 10000 40 (b_3:1e-06,(a_2:1e-06,a_... 5 5 0 10000 10000 53 (b_0:1e-06,(a_0:1e-06,a_... 6 6 0 10000 10000 52 (a_2:1e-06,a_0:1e-06,((a... 7 7 0 10000 10000 54 (b_1:1e-06,b_0:1e-06,b_2... 8 8 0 10000 10000 29 (((b_2:0.0004,b_3:1e-06,... 9 9 0 10000 10000 53 (a_3:1e-06,a_1:1e-06,a_2... In\u00a0[10]: Copied! <pre># infer gene tree from diploid sequences\ntree = ipcoal.phylo.infer_raxml_ng_tree(model, idxs=[1], diploid=True)\ntree.root(\"~a\").ladderize().draw(scale_bar=True);\n\n# infer gene tree from diploid sequences\ntree = ipcoal.phylo.infer_raxml_ng_tree(model, idxs=[1], diploid=False)\ntree.root(\"~a\").ladderize().draw(scale_bar=True);\n</pre> # infer gene tree from diploid sequences tree = ipcoal.phylo.infer_raxml_ng_tree(model, idxs=[1], diploid=True) tree.root(\"~a\").ladderize().draw(scale_bar=True);  # infer gene tree from diploid sequences tree = ipcoal.phylo.infer_raxml_ng_tree(model, idxs=[1], diploid=False) tree.root(\"~a\").ladderize().draw(scale_bar=True); b_2b_0b_3b_1a_0a_1a_2a_30.00080.00040 b_0b_5b_1b_4b_7b_2b_3b_6a_3a_1a_5a_6a_0a_7a_4a_20.00120.00080.00040 In\u00a0[101]: Copied! <pre># simulate sequences for two populations\nsptree = toytree.rtree.unittree(ntips=5, treeheight=1e6, seed=123)\nmodel = ipcoal.Model(sptree, Ne=400_000, nsamples=2, seed_mutations=123, seed_trees=123)\nmodel.sim_loci(nloci=1, nsites=100_000)\nmodel.draw_genealogies(shared_axes=True, scale_bar=100_000);\n</pre> # simulate sequences for two populations sptree = toytree.rtree.unittree(ntips=5, treeheight=1e6, seed=123) model = ipcoal.Model(sptree, Ne=400_000, nsamples=2, seed_mutations=123, seed_trees=123) model.sim_loci(nloci=1, nsites=100_000) model.draw_genealogies(shared_axes=True, scale_bar=100_000); r1_1r4_0r4_1r3_0r3_1r1_0r2_0r2_1r0_0r0_1051015r4_0r4_1r3_0r3_1r1_0r2_0r2_1r1_1r0_0r0_1051015r3_0r3_1r2_0r2_1r1_1r0_0r0_1r1_0r4_0r4_1051015r2_0r2_1r1_1r0_0r0_1r4_1r3_0r3_1r1_0r4_0051015 In\u00a0[103]: Copied! <pre># infer a concatenated gene tree for the locus\nctree = ipcoal.phylo.infer_raxml_ng_tree(model)\n\n# draw the concatenation tree\nctree.draw();\n</pre> # infer a concatenated gene tree for the locus ctree = ipcoal.phylo.infer_raxml_ng_tree(model)  # draw the concatenation tree ctree.draw(); r0_0r0_1r1_1r1_0r2_0r2_1r4_1r4_0r3_0r3_1 <p>Here I use the <code>toytree.distance.get_treedist_rfg_mci</code> to return the Generalized Robinson-Foulds distance using Mutual Clustering Information (MCI) to measure the distance between the concatenation tree and each observed genealogy across the length of the simulated chromosome.</p> In\u00a0[104]: Copied! <pre># measure MCI RF dist for each gene tree\ntdists = [ctree.distance.get_treedist_rfg_mci(i, normalize=True) for i in toytree.mtree(model.df.genealogy)]\n</pre> # measure MCI RF dist for each gene tree tdists = [ctree.distance.get_treedist_rfg_mci(i, normalize=True) for i in toytree.mtree(model.df.genealogy)] <p>We can then plot the tree distances along the length of the chromosome. You can see that for most parts of the genome the local genealogy does not match the concatenation tree topology. There is also a pattern of auto-correlation -- nearby regions of the genome tend to exhibit similar trees, and thus similar tree distances.</p> In\u00a0[120]: Copied! <pre>import toyplot\ncanvas = toyplot.Canvas(height=300)\naxes = canvas.cartesian(ylabel=\"Generalized RF distance\", xlabel=\"Genome position\")\naxes.fill(model.df.start, tdists)\naxes.x.ticks.locator = toyplot.locator.Extended(count=6)\naxes.x.ticks.show = axes.y.ticks.show = True\n</pre> import toyplot canvas = toyplot.Canvas(height=300) axes = canvas.cartesian(ylabel=\"Generalized RF distance\", xlabel=\"Genome position\") axes.fill(model.df.start, tdists) axes.x.ticks.locator = toyplot.locator.Extended(count=6) axes.x.ticks.show = axes.y.ticks.show = True 0250005000075000100000Genome position0.00.20.40.6Generalized RF distance"},{"location":"gene-tree-inference/#gene-tree-inference","title":"Gene tree inference\u00b6","text":"<p>Following the terminology used in ipcoal, gene trees refer to inferred hypotheses for the true genealogical relationships shared by a set of sampled genomes. Gene trees can be inferred from the sequence that evolve along the edges of genealogies. Our purpose here is to infer gene trees and compare them to the true genealogies.</p> <p>The <code>ipcoal.phylo</code> module can be used to implement common gene tree inference methods to simulated sequences under a variety of approaches to investigate sources of phylogenetic error. Some examples might include investigating how different demographic and simulation parameters affect sequence variation; how substitution models affect gene tree inference; how phased haploid versus diploid (ambiguity character) sequences affect accuracy; how separating sequences between recombination events versus concatenating them affects gene tree error; and many more.</p>"},{"location":"gene-tree-inference/#tldr","title":"tldr;\u00b6","text":"<p>Use <code>ipcoal.phylo.infer_raxml_ng_tree</code> to infer a gene tree from sequence data, or <code>ipcoal.phylo.infer_raxml_ng_trees</code> to return a dataframe with a collection of inferred trees from a set of sequences. These each take an <code>ipcoal.Model</code> class as input, and can select one or more loci to analyze individually, or as a concatenated sequence. In this example we infer gene trees for diploid sequences from 5 loci first as one large concatenated locus, and then also individually as separate loci.</p>"},{"location":"gene-tree-inference/#methods","title":"Methods\u00b6","text":""},{"location":"gene-tree-inference/#infer_raxml_ng_tree_from_alignment","title":"infer_raxml_ng_tree_from_alignment\u00b6","text":"<p>The function <code>infer_raxml_ng_tree_from_alignment</code> takes an alignment <code>str</code> as input and returns a <code>ToyTree</code> inferred by <code>raxml-ng</code>. You can toggle many arguments to <code>raxml-ng</code> using this function, but not all. It's primary utility is to provide a convenient shortcut to calling <code>raxml-ng</code> from Python which can also clean up the temporary files for you. This is the simplest of the three methods shown here. The examle below provides a phylip-formatted alignment as input and draws the inferred gene tree.</p>"},{"location":"gene-tree-inference/#infer_raxml_ng_tree","title":"infer_raxml_ng_tree\u00b6","text":"<p>The function <code>infer_raxml_ng_tree</code> provides quite a bit more functionality than the one above. This takes an <code>ipcoal.Model</code> object as input and provides a number of arguments for extracting one or more simulated loci from the object and optionally concatenating them (using the <code>idxs</code> arg), and an option to join haploid sequences into pairs as diploid sequences (using <code>diploid=True</code>). You can also toggle options to <code>raxml-ng</code>, including fine-tuning the parallelization. Under the hood, this function writes a phylip formatted sequence file to a temporary directory and calls raxml on the tmp file, then removes it. You can optionally set the <code>tmpdir</code> as an argument.</p>"},{"location":"gene-tree-inference/#infer_raxml_ng_trees","title":"infer_raxml_ng_trees\u00b6","text":"<p>The function <code>infer_raxml_ng_trees</code> is similar to the one above but in addition to the <code>raxml-ng</code> parallelization arguments <code>nthreads</code> (used per tree) and <code>nworkers</code> (num parallel boots per tree); it also includes an ipcoal-level parallelization option <code>njobs</code> for distributing the individual <code>infer_raxml_ng_tree</code> jobs in parallel. If you are working on a large cluster and running many thousands of small jobs you can use this to achieve much greater parallelization. Note, <code>raxml-ng</code> will raise an error if you request more resources among concurrently running jobs than are available. You should very much try to avoid this, as it slows things down greatly. But, if it occurs rarely during a job and you want to avoid the error you can use the options <code>do_not_autoscale_threads</code> and <code>perf_threads</code>.</p>"},{"location":"gene-tree-inference/#diploid-sequences","title":"Diploid sequences\u00b6","text":"<p>The option <code>diploid=True</code> joins haploid sequences from within the same population together to create diploid sequences. Because samples within the same population are treated as randomly mating (panmictic) the order in which they are joined should not matter. Therefore, we simply join samples sequentially ordered by their alphanumeric tip labels. For example, \"a_0\" and \"a_1\" will be joined to create a new diploid \"a_0\"; and \"a_2\" and \"a_3\" would be joined to create the new \"a_1\", and so on with sequential numbering. The effect of analyzing diploid sequences will be generally greater when heterozygosity of samples is greater.</p>"},{"location":"gene-tree-inference/#comparing-trees","title":"Comparing trees\u00b6","text":"<p>One of the core purposes of simulation is to compare inferred results to the ground truth. (See the Cookbooks/Examples section.) When simulating data we know the true genealogical history for our set of samples exactly at every position of their genomes. Therefore we can measure error as the differences between inferred gene trees and the true genealogies. One way to do this is to use tree distance metrics, many of which are implemented in toytree.</p> <p>In the example below we simulate a tree sequence across a 100Kb locus for 5-tip species tree and sample 2 genomes per lineage. This creates 449 genealogies.</p>"},{"location":"installation/","title":"Installation","text":"<p><code>ipcoal</code> can be installed using pip or conda, either of which will pull in  all required dependencies. We also provide instructions below for installing from source (GitHub).</p>"},{"location":"installation/#conda-install-recommended","title":"Conda install (recommended)","text":"<pre><code>$ conda install ipcoal -c conda-forge\n</code></pre>"},{"location":"installation/#pip-install","title":"Pip install","text":"<pre><code>$ pip install ipcoal\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>Our goal is to maintain <code>ipcoal</code> as a small library that does not require substantial dependencies outside of the standard Python scientific stack (i.e., numpy, scipy, and pandas).</p> <pre><code>- python&gt;=3.7\n- numpy\n- scipy\n- pandas\n- loguru\n- toytree\n- msprime\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional dependencies","text":"<p><code>ipcoal</code> includes several submodules that provide wrappers around external phylogenetic inference tools, such as raxml-ng, Astral, SNaQ, and others.  These tools are optional. When you call the function it will raise an exception if the required binary cannot be found in your path and will provide recommendations for how to install it using conda.</p>"},{"location":"installation/#installing-development-versions","title":"Installing Development Versions","text":"<pre><code>$ conda install ipcoal -c conda-forge --only-deps\n$ git clone https://github.com/eaton-lab/ipcoal.git\n$ cd ipcoal\n$ pip install -e . --no-deps\n</code></pre>"},{"location":"installation/#building-the-documentation","title":"Building the documentation","text":"<pre><code>$ conda install mkdocs-material mkdocstrings-python mkdocs-jupyter -c conda-forge\n$ cd ipcoal/\n$ mkdocs serve\n</code></pre>"},{"location":"interaction-with-tskit/","title":"Interaction with tskit","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport ipcoal\n</pre> import toytree import ipcoal In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[2]: Copied! <pre># or, you can \nmodel.store_tree_sequences = True\nmodel.sim_trees(5)\nmodel.ts_dict\n</pre> # or, you can  model.store_tree_sequences = True model.sim_trees(5) model.ts_dict <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 2\n      1 # or, you can \n----&gt; 2 model.store_tree_sequences = True\n      3 model.sim_trees(5)\n      4 model.ts_dict\n\nNameError: name 'model' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"interaction-with-tskit/#interaction-with-tskit","title":"Interaction with tskit\u00b6","text":""},{"location":"network-inference/","title":"Network inference","text":"In\u00a0[3]: Copied! <pre>import ipcoal\nimport toytree\nimport msprime\n</pre> import ipcoal import toytree import msprime <p>tldr;</p> <p>Call the `ipcoal.phylo.infer_astral_tree` method to infer a species tree using ASTRAL-III from a set of gene trees. This function will return the result as a ToyTree object with optional support values stored to the tree data. </p> In\u00a0[23]: Copied! <pre># get a 5-tip imbalanced species tree w/ equal internal edges\nsptree = toytree.rtree.unittree(ntips=5, treeheight=5e5, seed=123)\n\n# define a species network\nmodel = ipcoal.Model(sptree, admixture_edges=[(2, 3, 300_000, 0.1)], Ne=2e5, nsamples=4, seed_trees=123, seed_mutations=123)\n\n# simulate 100 loci x 1000 sites under the demographic model\nmodel.sim_loci(nloci=100, nsites=1000)\n\n# draw the demographic model with the first genealogy embedded\nmodel.draw_sptree(scale_bar=1e5);\n</pre> # get a 5-tip imbalanced species tree w/ equal internal edges sptree = toytree.rtree.unittree(ntips=5, treeheight=5e5, seed=123)  # define a species network model = ipcoal.Model(sptree, admixture_edges=[(2, 3, 300_000, 0.1)], Ne=2e5, nsamples=4, seed_trees=123, seed_mutations=123)  # simulate 100 loci x 1000 sites under the demographic model model.sim_loci(nloci=100, nsites=1000)  # draw the demographic model with the first genealogy embedded model.draw_sptree(scale_bar=1e5); 012345678r0r1r2r3r4012345 In\u00a0[24]: Copied! <pre># show the first 10 trees in the result dataframe\nmodel.df.head(10)\n</pre> # show the first 10 trees in the result dataframe model.df.head(10) Out[24]: locus start end nbps nsnps tidx genealogy 0 0 0 158 158 11 0 (((r3_1:114096.469358424... 1 0 158 235 77 4 1 (((r3_1:114096.469358424... 2 0 235 285 50 1 2 (((r3_1:114096.469358424... 3 0 285 321 36 1 3 ((r1_2:490204.8777700350... 4 0 321 333 12 1 4 ((r1_2:490204.8777700350... 5 0 333 380 47 4 5 ((r1_2:490204.8777700350... 6 0 380 826 446 22 6 ((r1_2:490204.8777700350... 7 0 826 935 109 7 7 ((r1_2:490204.8777700350... 8 0 935 951 16 1 8 ((r1_2:490204.8777700350... 9 0 951 1000 49 4 9 ((r1_2:490204.8777700350... <p>However, it is important to consider how these data actually match to the expectations of the multi-species coalescent. For example, if you simulate the coalescent with a recombination rate &gt; 0 for loci that are longer than 1 site in length, as we did here, then each locus may contain more than one genealogy. Indeed, we can see in the dataframe above that the first locus contains 8 genealogies. If we were to input all of these genealogies into SNAQ it would technically violate an assumption of the MSC model that the trees are expected to be statistically independent. Instead, it would be more appropriate to sample one genealogy per locus, perhaps the first one, or the longest one. Below we extract the full set of genealogies, and a subset composing just one genealogy per locus. Here the trees are stored as a <code>pd.Series</code> object, which can be used in downstream steps, but it could just as well be a list or any collection object. We will analyze the trees in the next section.</p> In\u00a0[25]: Copied! <pre># get all simulated genealogies\nall_genealogies = model.df.genealogy\n</pre> # get all simulated genealogies all_genealogies = model.df.genealogy In\u00a0[26]: Copied! <pre># sample the first tree from every locus\nfirst_genealogies = model.df.genealogy[model.df.tidx == 0]\n</pre> # sample the first tree from every locus first_genealogies = model.df.genealogy[model.df.tidx == 0] <p>Using a multitree drawing from toytree we can view the first several simulated genealogies and see that there is some amount of ILS in each tree. We can see also that the trees are fully resolved and the tips align at zero. This is what simulated coalescent genealogies will usually look like.</p> In\u00a0[27]: Copied! <pre># draw the first four trees\ntoytree.mtree(first_genealogies).draw(shape=(1, 4), height=350);\n</pre> # draw the first four trees toytree.mtree(first_genealogies).draw(shape=(1, 4), height=350); r3_1r3_2r3_0r3_3r4_2r4_3r4_0r4_1r1_0r1_1r2_2r2_3r2_0r2_1r1_2r1_3r0_2r0_3r0_0r0_1r2_2r2_0r2_1r2_3r1_2r1_3r0_1r1_1r0_0r1_0r0_2r0_3r4_0r4_3r4_1r4_2r3_1r3_3r3_0r3_2r0_0r2_1r1_2r0_1r1_3r1_0r1_1r2_0r3_1r3_3r3_0r3_2r4_0r4_3r4_1r4_2r0_2r0_3r2_2r2_3r0_3r1_1r2_1r2_2r2_3r1_0r1_2r1_3r2_0r0_0r0_1r0_2r3_1r4_0r4_1r4_2r4_3r3_0r3_2r3_3 In\u00a0[28]: Copied! <pre># infer gene tree for each locus from 4 haploid samples\ngene_trees_haploid = ipcoal.phylo.infer_raxml_ng_trees(model, nboots=0, nthreads=4, nproc=2)\n</pre> # infer gene tree for each locus from 4 haploid samples gene_trees_haploid = ipcoal.phylo.infer_raxml_ng_trees(model, nboots=0, nthreads=4, nproc=2) In\u00a0[29]: Copied! <pre># infer gene tree for each locus from 2 diploid samples\ngene_trees_diploid = ipcoal.phylo.infer_raxml_ng_trees(model, diploid=True, nboots=0, nthreads=4, nproc=2)\n</pre> # infer gene tree for each locus from 2 diploid samples gene_trees_diploid = ipcoal.phylo.infer_raxml_ng_trees(model, diploid=True, nboots=0, nthreads=4, nproc=2) In\u00a0[30]: Copied! <pre>haploid_imap = model.get_imap_dict()\nhaploid_imap\n</pre> haploid_imap = model.get_imap_dict() haploid_imap Out[30]: <pre>{'r0': ['r0_0', 'r0_1', 'r0_2', 'r0_3'],\n 'r1': ['r1_0', 'r1_1', 'r1_2', 'r1_3'],\n 'r2': ['r2_0', 'r2_1', 'r2_2', 'r2_3'],\n 'r3': ['r3_0', 'r3_1', 'r3_2', 'r3_3'],\n 'r4': ['r4_0', 'r4_1', 'r4_2', 'r4_3']}</pre> In\u00a0[31]: Copied! <pre>diploid_imap = model.get_imap_dict(diploid=True)\ndiploid_imap\n</pre> diploid_imap = model.get_imap_dict(diploid=True) diploid_imap Out[31]: <pre>{'r0': ['r0_0', 'r0_1'],\n 'r1': ['r1_0', 'r1_1'],\n 'r2': ['r2_0', 'r2_1'],\n 'r3': ['r3_0', 'r3_1'],\n 'r4': ['r4_0', 'r4_1']}</pre> In\u00a0[32]: Copied! <pre># infer sptree from all genealogies (multiple linked trees per locus)\natree1 = ipcoal.phylo.infer_snaq_network(all_genealogies, imap=haploid_imap)\n</pre> # infer sptree from all genealogies (multiple linked trees per locus) atree1 = ipcoal.phylo.infer_snaq_network(all_genealogies, imap=haploid_imap) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[32], line 2\n      1 # infer sptree from all genealogies (multiple linked trees per locus)\n----&gt; 2 atree1 = ipcoal.phylo.infer_snaq_network(all_genealogies, imap=haploid_imap)\n\nTypeError: infer_snaq_network() got an unexpected keyword argument 'imap'</pre> In\u00a0[13]: Copied! <pre># infer sptree from unlinked genealogies (1 per locus)\natree2 = ipcoal.phylo.infer_astral_tree(first_genealogies, imap=haploid_imap)\n</pre> # infer sptree from unlinked genealogies (1 per locus) atree2 = ipcoal.phylo.infer_astral_tree(first_genealogies, imap=haploid_imap) In\u00a0[21]: Copied! <pre># infer sptree from inferred gene trees haploid\natree3 = ipcoal.phylo.infer_astral_tree(gene_trees_haploid.gene_tree, imap=haploid_imap)\n</pre> # infer sptree from inferred gene trees haploid atree3 = ipcoal.phylo.infer_astral_tree(gene_trees_haploid.gene_tree, imap=haploid_imap) In\u00a0[23]: Copied! <pre># infer sptree from inferred gene trees diploid\natree4 = ipcoal.phylo.infer_astral_tree(gene_trees_diploid.gene_tree, imap=diploid_imap)\n</pre> # infer sptree from inferred gene trees diploid atree4 = ipcoal.phylo.infer_astral_tree(gene_trees_diploid.gene_tree, imap=diploid_imap) In\u00a0[29]: Copied! <pre>toytree.mtree([atree1, atree2, atree3, atree4]).root(\"r3\", \"r4\").draw();\n</pre> toytree.mtree([atree1, atree2, atree3, atree4]).root(\"r3\", \"r4\").draw(); r3r4r0r1r2r3r4r0r1r2r4r3r0r1r2r2r0r1r3r4"},{"location":"network-inference/#species-tree-inference","title":"Species tree inference\u00b6","text":"<p>We currently implement a wrapper for the phylogenetic network inference tool SNAQ implemented in phylonetworks in Julia. This takes a set of unrooted trees as input and returns an unrooted network. This method can be called from <code>ipcoal.phylo.infer_snaq_network</code>. It requires that you have <code>julia</code> and the phylonetworks package installed.</p>"},{"location":"network-inference/#example-dataset","title":"Example dataset\u00b6","text":"<p>Here we set up a demographic model composing a species network with 5 lineages r0-r4, including an admixture edge from r3 to r2. The root node height is at 0.5M generations, and internal edges are set to equal lengths of ~166K generations. Each interval Ne is set to 2e5, which corresponds to an internal edge length of 0.42 coalescent units. As you can see in the visualization below, this corresponds to a small amount of ILS among the 4 sampled gene copies per lineage. We simulated 1000 loci each 1000 sites in length.</p>"},{"location":"network-inference/#getting-tree-sets","title":"Getting tree sets\u00b6","text":""},{"location":"network-inference/#genealogies","title":"Genealogies\u00b6","text":"<p>We can apply ASTRAL to infer a species tree from coalescent simulated data in a number of ways. First, we might be interested in the species tree that can be inferred from perfectly accurate input trees. We have these in the form of the simulated genealogies that are stored in the \"genealogy\" column of the <code>Model.df</code> dataframe.</p>"},{"location":"network-inference/#gene-trees","title":"Gene trees\u00b6","text":"<p>We can also apply ASTRAL to infer a species tree from inferred gene trees. This is more similar to the analysis of real data, where gene trees may have unresolved nodes, variable branch lengths, and mismodeled substitutions rates (you could investigate other sources of error as well like missing samples or alignment errors.) Here we will use the ipcoal wrapper for raxml-ng to infer gene trees, but you could alternative use any method to infer trees that could then be loaded back in as ToyTrees from newick, nexus, or related text formats. A benefit of using the raxml wrapper in toytree is that we can easily automate the process of writing the sequence data, analyzing it, and loading back in the results. To keep things fast we do not estimate bootstrap supports for the gene trees here, but this can be easily added.</p>"},{"location":"network-inference/#imap-dict","title":"IMAP dict\u00b6","text":"<p>When your data contains multiple individuals or gene copies per lineage it is typical to provide a mapping (imap) to tell the species tree inference software which genomes are members of the same lineage. This is entered to the <code>ipcoal.infer_astral_tree</code> method as a dictionary, where the keys are species tree tip names, and the values are lists of sample names that belong to that species. It is easy to extract an imap dict for simulations performed from an <code>ipcoal.Model</code> object by calling its <code>.get_imap_dict</code> function, which accepts are argument for whether or not pairs samples will be joined into diploid samples.</p>"},{"location":"network-inference/#todo-implement-imap","title":"TODO: Implement IMAP\u00b6","text":""},{"location":"network-inference/#infer-species-network","title":"Infer species network\u00b6","text":"<p>See the ASTRAL III documentation for further details on options that can be run.</p>"},{"location":"network-inference/#compare-species-trees","title":"Compare species trees\u00b6","text":"<p>In this case, all of the trees inferred the same species tree topology, which is not surprising since we simulated a pretty large dataset with a limited amount of ILS, which is a scenario where astral can be quite accurate. However, we can see that the different datasets have resulted in difference estimates of support and branch lengths (in coalescent units).</p>"},{"location":"quick_guide/","title":"Quick guide","text":"In\u00a0[1]: Copied! <pre>import ipcoal\nimport toytree\n</pre> import ipcoal import toytree In\u00a0[119]: Copied! <pre># setup a single-population demographic model\nmodel = ipcoal.Model(Ne=1000, nsamples=6, seed_trees=123)\n\n# simulate one genealogical tree under this model\nmodel.sim_trees(nloci=1, nsites=1)\n\n# draw the first genealogy embedded in the demographic model\nmodel.draw_demography(idx=0);\n</pre> # setup a single-population demographic model model = ipcoal.Model(Ne=1000, nsamples=6, seed_trees=123)  # simulate one genealogical tree under this model model.sim_trees(nloci=1, nsites=1)  # draw the first genealogy embedded in the demographic model model.draw_demography(idx=0); idx=0 Ne=1e+03 Tc=inf Tg=infp_3p_5p_0p_4p_1p_2node=0node=1node=2node=3node=4node=5node=6node=7node=8node=9node=10010002000 In\u00a0[120]: Copied! <pre># set up a 3-tip species tree with root at 1e4 generations\nsptree = toytree.rtree.imbtree(ntips=3, treeheight=1e4)\n\n# set up a demographic model using the species tree\nmodel = ipcoal.Model(tree=sptree, Ne=5000, nsamples={0: 2, 1: 3, 2: 4}, seed_trees=1234)\n\n# simulate one genealogy\nmodel.sim_trees(1)\n\n# draw the genealogy embedded in the species tree model\nmodel.draw_demography(idx=0);\n</pre> # set up a 3-tip species tree with root at 1e4 generations sptree = toytree.rtree.imbtree(ntips=3, treeheight=1e4)  # set up a demographic model using the species tree model = ipcoal.Model(tree=sptree, Ne=5000, nsamples={0: 2, 1: 3, 2: 4}, seed_trees=1234)  # simulate one genealogy model.sim_trees(1)  # draw the genealogy embedded in the species tree model model.draw_demography(idx=0); idx=3 Ne=5e+03 Tc=0.5 Tg=5e+03idx=2 Ne=5e+03 Tc=1 Tg=1e+04idx=0 Ne=5e+03 Tc=0.5 Tg=5e+03idx=1 Ne=5e+03 Tc=0.5 Tg=5e+03idx=4 Ne=5e+03 Tc=0 Tg=0r0_0r0_1r1_0r1_1r1_2r2_2r2_3r2_0r2_1node=1node=2node=9node=0node=7node=8node=3node=4node=5node=6node=11node=12node=13node=14node=10node=15node=1601000020000 <p>Branch lengths on demographic models</p> <p>See Demography and Species Trees for tips on translating branch lengths on empirical trees from units of absolute time or coalescent units to generations.</p> In\u00a0[191]: Copied! <pre># simulate a single genealogy (i.e., for 1 locus at one site)\nmodel.sim_trees()\n</pre> # simulate a single genealogy (i.e., for 1 locus at one site) model.sim_trees() In\u00a0[192]: Copied! <pre># same as above (showing default arguments)\nmodel.sim_trees(nloci=1, nsites=1)\n</pre> # same as above (showing default arguments) model.sim_trees(nloci=1, nsites=1) In\u00a0[193]: Copied! <pre># simulate 10 independent loci each containing one genealogy\nmodel.sim_trees(10)\n</pre> # simulate 10 independent loci each containing one genealogy model.sim_trees(10) In\u00a0[194]: Copied! <pre># simulate 1 locus of len=10000. May contain multiple trees if recomb.\nmodel.sim_trees(nloci=1, nsites=1e4)\n</pre> # simulate 1 locus of len=10000. May contain multiple trees if recomb. model.sim_trees(nloci=1, nsites=1e4) In\u00a0[196]: Copied! <pre># simulate 2 loci each 100bp in length\nmodel.sim_loci(nloci=2, nsites=100)\n</pre> # simulate 2 loci each 100bp in length model.sim_loci(nloci=2, nsites=100) In\u00a0[197]: Copied! <pre># simulate 5 unlinked SNPs\nmodel.sim_snps(nsnps=5)\n</pre> # simulate 5 unlinked SNPs model.sim_snps(nsnps=5) <p>Why do you need to specify `nsites` when simulating genealogies?</p> <p>If the simulation includes recombination (which it does by default) then a single locus extending over more than one site may actually represent multiple coalescent genealogies if a recombination crossover occurred in the history of the samples at that locus. See the linked genealogy example below.</p> In\u00a0[229]: Copied! <pre># simulate unlinked genealogies\nmod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123)\nmod.sim_loci(nloci=10, nsites=1)\nmod.df\n</pre> # simulate unlinked genealogies mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123) mod.sim_loci(nloci=10, nsites=1) mod.df Out[229]: locus start end nbps nsnps tidx genealogy 0 0 0 1 1 0 0 (p_1:287537.351532411179... 1 1 0 1 1 0 0 (p_3:110157.870294456748... 2 2 0 1 1 0 0 ((p_0:1313.6091112858539... 3 3 0 1 1 0 0 (p_0:314684.858664838480... 4 4 0 1 1 0 0 (p_1:147864.053017845842... 5 5 0 1 1 0 0 (p_0:93326.6807769358565... 6 6 0 1 1 0 0 (p_3:143619.984664270363... 7 7 0 1 1 0 0 ((p_2:70699.778029327673... 8 8 0 1 1 0 0 ((p_0:14776.914259654118... 9 9 0 1 1 0 0 ((p_1:17689.798992805852... In\u00a0[230]: Copied! <pre># simulate linked genealogies\nmod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123)\nmod.sim_loci(nloci=2, nsites=1e4)\nmod.df\n</pre> # simulate linked genealogies mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123) mod.sim_loci(nloci=2, nsites=1e4) mod.df Out[230]: locus start end nbps nsnps tidx genealogy 0 0 0 3380 3380 23 0 ((p_1:12194.366367953536... 1 0 3380 4888 1508 11 1 ((p_1:12194.366367953536... 2 0 4888 6243 1355 11 2 ((p_1:12194.366367953536... 3 0 6243 6811 568 4 3 (p_4:504559.306961862370... 4 0 6811 6910 99 0 4 ((p_1:12194.366367953536... 5 0 6910 6971 61 1 5 ((p_1:12194.366367953536... 6 0 6971 8463 1492 29 6 ((p_1:12194.366367953536... 7 0 8463 10000 1537 12 7 ((p_1:12194.366367953536... 8 1 0 7642 7642 22 0 ((p_2:13777.964596574553... 9 1 7642 7935 293 2 1 ((p_0:25416.063867531960... 10 1 7935 10000 2065 11 2 ((p_0:25416.063867531960... In\u00a0[228]: Copied! <pre># draw the first tree\nmod.draw_genealogy(idx=0, scale_bar=1e3);\n\n# draw N trees on the same scale\nmod.draw_genealogies(idxs=range(4), scale_bar=1e3, shared_axes=True);\n</pre> # draw the first tree mod.draw_genealogy(idx=0, scale_bar=1e3);  # draw N trees on the same scale mod.draw_genealogies(idxs=range(4), scale_bar=1e3, shared_axes=True); p_1p_3p_4p_0p_20100200 p_1p_3p_4p_0p_20100200300400500p_1p_3p_4p_0p_20100200300400500p_1p_3p_4p_0p_20100200300400500p_4p_0p_2p_1p_30100200300400500 In\u00a0[255]: Copied! <pre>mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123)\nmod.sim_loci(nloci=1, nsites=70)\nmod.seqs\n</pre> mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123) mod.sim_loci(nloci=1, nsites=70) mod.seqs Out[255]: <pre>array([[[0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 2, 1, 3, 2, 1, 3, 1, 3, 2, 1,\n         1, 0, 1, 2, 3, 1, 1],\n        [0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 2, 1, 3, 2, 1, 3, 1, 3, 2, 1,\n         1, 0, 1, 2, 3, 1, 1],\n        [0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 2, 1, 3, 2, 1, 3, 1, 3, 2, 1,\n         1, 0, 1, 2, 3, 1, 1],\n        [0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 2, 1, 3, 2, 1, 3, 1, 3, 2, 1,\n         1, 0, 1, 2, 3, 1, 1],\n        [0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 2, 1, 3, 2, 1, 3, 1, 3, 2, 1,\n         1, 0, 1, 2, 3, 1, 1]]], dtype=uint8)</pre> In\u00a0[250]: Copied! <pre># simulate 1 locus and write as phylip format\nmod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123)\nmod.sim_loci(nloci=1, nsites=70)\nprint(mod.write_concat_to_phylip())\n</pre> # simulate 1 locus and write as phylip format mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123) mod.sim_loci(nloci=1, nsites=70) print(mod.write_concat_to_phylip()) <pre>5 70\np_0        AAAATTCTTGATAGGTATGAACGAACGTGTTATGCTTCGAGATACAACCACACGCTGCTCTGCCACGTCC\np_1        AAAATTCTTGATAGGTATGAACGAACGTGTTATGCTTCGAGATACAACCACACGCTGCTCTGCCACGTCC\np_2        AAAATTCTTGATAGGTATGAACGAACGTGTTATGCTTCGAGATACAACCACACGCTGCTCTGCCACGTCC\np_3        AAAATTCTTGATAGGTATGAACGAACGTGTTATGCTTCGAGATACAACCACACGCTGCTCTGCCACGTCC\np_4        AAAATTCTTGATAGGTATGAACGAACGTGTTATGCTTCGAGATACAACCACACGCTGCTCTGCCACGTCC\n</pre> In\u00a0[252]: Copied! <pre># simulate 5 unlnked SNPs and write as VCF format\nmod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123)\nmod.sim_snps(5)\nmod.write_vcf()\n</pre> # simulate 5 unlnked SNPs and write as VCF format mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123) mod.sim_snps(5) mod.write_vcf() Out[252]: CHROM POS ID REF ALT QUAL FILTER INFO FORMAT p_0 p_1 p_2 p_3 p_4 0 1 1 . G A 99 PASS . GT 0|0 0|0 0|0 0|0 1|1 1 2 1 . C T 99 PASS . GT 0|0 0|0 1|1 0|0 0|0 2 3 1 . T G 99 PASS . GT 1|1 0|0 1|1 1|1 1|1 3 4 1 . G A 99 PASS . GT 1|1 0|0 1|1 0|0 0|0 4 5 1 . C T 99 PASS . GT 1|1 0|0 0|0 0|0 1|1 In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[113]: Copied! <pre>\n</pre> p_4p_2p_3p_0p_10200400600p_2p_4p_1p_0p_30200400600p_3p_0p_2p_1p_40200400600p_1p_3p_2p_0p_40200400600 In\u00a0[115]: Copied! <pre># simulate linked genealogies\nlinked = ipcoal.Model(Ne=1e5, nsamples=5, recomb=1e-9, seed_trees=1234)\nlinked.sim_trees(nloci=1, nsites=100000)\nlinked.df.head(10)\n</pre> # simulate linked genealogies linked = ipcoal.Model(Ne=1e5, nsamples=5, recomb=1e-9, seed_trees=1234) linked.sim_trees(nloci=1, nsites=100000) linked.df.head(10) Out[115]: locus start end nbps nsnps tidx genealogy 0 0 0 1727 1727 0 0 ((p_3:67790.975409283491... 1 0 1727 3972 2245 0 1 ((p_3:67790.975409283491... 2 0 3972 5462 1490 0 2 ((p_3:67790.975409283491... 3 0 5462 11745 6283 0 3 (p_0:216324.742533758428... 4 0 11745 12782 1037 0 4 (((p_1:28107.65126587526... 5 0 12782 17877 5095 0 5 ((p_0:112441.59260623497... 6 0 17877 19547 1670 0 6 ((p_0:112441.59260623497... 7 0 19547 21444 1897 0 7 ((p_0:112441.59260623497... 8 0 21444 21464 20 0 8 (p_4:513071.323730750300... 9 0 21464 23818 2354 0 9 (p_4:534342.730756848352... In\u00a0[116]: Copied! <pre>linked.draw_genealogies(shared_axes=True, scale_bar=1000);\n</pre> linked.draw_genealogies(shared_axes=True, scale_bar=1000); p_3p_4p_0p_1p_2050100150200p_3p_4p_0p_1p_2050100150200p_3p_4p_0p_1p_2050100150200p_0p_1p_2p_3p_4050100150200 In\u00a0[118]: Copied! <pre>linked.draw_tree_sequence();\n</pre> linked.draw_tree_sequence(); <pre>\n---------------------------------------------------------------------------\nNotImplementedError                       Traceback (most recent call last)\nCell In[118], line 1\n----&gt; 1 linked.draw_tree_sequence();\n\nFile ~/Documents/ipcoal/ipcoal/model.py:830, in Model.draw_tree_sequence(self, **kwargs)\n    828 def draw_tree_sequence(self, **kwargs):\n    829     \"\"\"Return a toytree TreeSequence drawing.\"\"\"\n--&gt; 830     raise NotImplementedError(\"TODO..\")\n\nNotImplementedError: TODO..</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[80]: Copied! <pre>model.draw_seqview(idx=0, start=0, end=100);\n</pre> model.draw_seqview(idx=0, start=0, end=100); r0_0r0_1r1_0r1_1r1_2r2_0r2_1r2_2r2_3 In\u00a0[75]: Copied! <pre># set Model to store TreeSequences as results\nmodel.store_tree_sequences = True\n\n# simulate a 10Kb locus\nmodel.sim_loci(1, 10000)\n\n# draw genealogy with substitutions\nmodel.draw_genealogy(idx=0, show_substitutions=True);\n</pre> # set Model to store TreeSequences as results model.store_tree_sequences = True  # simulate a 10Kb locus model.sim_loci(1, 10000)  # draw genealogy with substitutions model.draw_genealogy(idx=0, show_substitutions=True); r2_0r1_0r1_1r1_2r2_1r2_2r2_3r0_0r0_1id: 0 site: 0 time: 17443 mtype: 0id: 1 site: 1 time: 15134 mtype: 0id: 2 site: 2 time: 5347 mtype: 0id: 3 site: 3 time: 9790 mtype: 0id: 4 site: 4 time: 14352 mtype: 0id: 5 site: 5 time: 1085 mtype: 0id: 6 site: 6 time: 2895 mtype: 0id: 7 site: 7 time: 27678 mtype: 03000020000100000tree in interval 0 (sites 0-10000) <p>Core features of the ipcoal + toytree framework include:</p> <ul> <li>xMethods to describe and visualize demographic models.</li> <li>Methods to access tree sequences directly.</li> <li>Methods to access coalescent trees as a summarized dataframe.</li> <li>Methods for simulating conditioned unlinked SNPs</li> <li>Methods for simulating multi-locus linked or unlinked data.</li> <li>Methods for writing SNPs or entire loci in a number of file formats.</li> <li>Methods for inferring phylogenetic trees from simulated data.</li> <li>Methods for calculating distances/statistics on trees.</li> </ul> In\u00a0[71]: Copied! <pre># setup a single-population demographic model\nmodel = ipcoal.Model(Ne=1000, nsamples=10, store_tree_sequences=True)\n\n# simulate a genealogy\nmodel.sim_trees(nloci=2, nsites=1)\n\n# access the tree sequences\nmodel.ts_dict\n</pre> # setup a single-population demographic model model = ipcoal.Model(Ne=1000, nsamples=10, store_tree_sequences=True)  # simulate a genealogy model.sim_trees(nloci=2, nsites=1)  # access the tree sequences model.ts_dict Out[71]: <pre>{0: &lt;tskit.trees.TreeSequence at 0x7fee67206c20&gt;,\n 1: &lt;tskit.trees.TreeSequence at 0x7fee677d0760&gt;}</pre> <p>If you are only interested in sampling a TreeSequence object, this can also be done in a simple way...</p> In\u00a0[75]: Copied! <pre># setup a single-population demographic model\nmodel = ipcoal.Model(Ne=1000, nsamples=10, store_tree_sequences=True)\n\n# sample one TreeSequence\nts = model.get_tree_sequence(nsites=10)\n\n# show the TreeSequence\nrepr(ts)\n</pre> # setup a single-population demographic model model = ipcoal.Model(Ne=1000, nsamples=10, store_tree_sequences=True)  # sample one TreeSequence ts = model.get_tree_sequence(nsites=10)  # show the TreeSequence repr(ts) Out[75]: <pre>'&lt;tskit.trees.TreeSequence object at 0x7fee690232e0&gt;'</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[77]: Copied! <pre># setup a single-population demographic model\nmodel = ipcoal.Model(Ne=1000, nsamples=10, store_tree_sequences=True)\n\nmodel.sim_trees(nloci=2, nsites=100)\n\nmodel.df\n</pre> # setup a single-population demographic model model = ipcoal.Model(Ne=1000, nsamples=10, store_tree_sequences=True)  model.sim_trees(nloci=2, nsites=100)  model.df Out[77]: locus start end nbps nsnps tidx genealogy 0 0 0 100 100 0 0 ((p_2:1724.1829204845337... 1 1 0 100 100 0 0 (p_5:4708.95883675882396... In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>The species tree is the primary model on which ipcoal is designed to simulate genealogies and sequences within the multispecies coalescent framework. One of the primary features of ipcoal is the ability to feed it a tree which it will then parse to build a demographic model (which is used by the <code>msprime</code> coalescent simulator), and which describes when and how different populations (lineages) are able to coalesce with each other. You can think of coalescence on a species tree as several distinct coalescent processes occurring within panmictic populations that are simply connected to each other by the tree structure (See Degnan and Rosenberg 2009 for a nice description).</p> <p>To simulate genealogies and sequences on a tree we need to first define the tree. This can be done by either loading an inferred tree from a newick string or by generating a random tree. For this we will use the tree manipulation and visualization library toytree. In the example cell below I use toytree to generate a random tree with a set number of tips, a total tree height, and a random seed, and store it as a variable named <code>tree1</code>.</p> <p>We can visualize this tree by calling <code>.draw()</code> from the toytree and here I provide the argument <code>tree_style='p'</code> to set a style for drawing the figure that will make it look nice for representing 'population trees' (i.e., species trees). This is helpful in that it provides numeric labels on the nodes of the tree, shows tip labels, and provides a scalebar for the height of the tree.</p> In\u00a0[3]: Copied! <pre>ipcoal.Model\n</pre> ipcoal.Model Out[3]: <pre>ipcoal.model.Model</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"quick_guide/#quick-guide","title":"Quick Guide\u00b6","text":"<p>Welcome to the quick guide tutorial for ipcoal. This page is intended to introduce major concepts of coalescent simulations and to provide a concise overview of several types of statistical evolutionary analyses that can be performed in ipcoal. This documentation demonstrates ipcoal through a series of examples that combine analyses alongside visualizations, in the style of a jupyter notebook, where Python code can be executed interactively. The Python package toytree is installed alongside ipcoal and should typically be imported with it, like below, as the two are intended to work hand-in-hand.</p> <p>Follow along in this guide to learn how to set up a parameterized demographic model; simulate coalescent genealogies and sequences; calculate likelihoods of observed data; apply phylogenetic inference tools to sequences; and compare inferred gene trees to simulated genealogies. Explore the documentation to learn more details about each of these steps and explore other features of ipcoal.</p>"},{"location":"quick_guide/#a-population-model","title":"A population model\u00b6","text":"<p>A core concept in evolutionary genetics is the use of population demographic models to represent a set of simplifying assumptions about how gene copies are replicated and inherited from one generation to the next (see Kingman coalescent). Complex evolutionary simulations can extend and relax many of these simplifying assumptions to develop highly detailed models of molecular evolution to emulate almost any natural phenomenon. However, simple models of evolution are also very useful, as they provide a means to establish null expectations for patterns of diversity and divergence in the absence of more complex processes. The coalescent model sits in the latter category, as a model for simulating neutral evolution given the parameters of a population demographic model. The major application of the coalescent is typically to treat the genealogical variation at any particular region of the genome as a random variable, and to examine the distribution of genealogies from many parts of the genome -- and/or DNA sequences evolved on those genealogies -- to infer features of the demographic model under which they evolved.</p> <p>The main object in ipcoal is the <code>ipcoal.Model</code> class object, which represents a parameterized population demographic model, and can be used to perform coalescent simulations and/or fit simulated data to model parameters, and perform additional analyses on simulated trees or sequences. It is easy to set up parameterized Model objects to represent a single population, multiple structured populations (i.e., a species tree), or a network of connected populations (i.e., phylogenetic network).</p>"},{"location":"quick_guide/#single-population","title":"Single population\u00b6","text":"<p>The simplest population demographic model is a single panmictic population with constant diploid effective population size (Ne). In ipcoal this can be initiated as a <code>Model</code> class object provided with an <code>Ne</code> parameter. Here I also set the <code>nsamples</code> and <code>seed_trees</code> parameters to set the number of gene copies to sample, and a random seed for coalescent simulation, respectively. More details about these function calls to simulate trees and draw visualizations will be explained further below. The key concept here is to understand that the genealogy (shown with green edges) represents one randomly sampled history for a set of six gene copies in a population with diploid effective size of 1000. The visualization, which shows a gene tree embedded in a grey rectangle, represents an embedding of the genealogy within the demographic model (i.e., the model is a container within which the genealogy must fit). In this example the gene copies coalesce to a common ancestor a little over 2000 generations ago.</p>"},{"location":"quick_guide/#population-divergence","title":"Population divergence\u00b6","text":"<p>As a slightly more complex example, we can next set up a simulation that involves population structure in the form of a species tree. Here we use <code>toytree</code> to create a <code>ToyTree</code> object that represents a tree with three lineages that have equally spaced divergence times and a crown height of 1e4 generations (note: the <code>toytree</code> library can be used to create a species tree in a number of ways). This tree object can be passed as the first argument to the <code>ipcoal.Model</code> to designate the number of populations and their relationships. We can then set a single Ne to apply to all populations, or different Ne values for each. Here we set a single value. Similarly, we could sample the same number of gene copies from each population, or sample different numbers from each, as we do here using a dict. You can hover your cursor over the visualization to view additional information about each population interval in the demographic model. This will list values for interval's index ID, Ne value, and length in units of generations (t$_g$) and coalescent units (t$_c$). Here we can see by embedding the simulated genealogy into the species tree that the gene copies from the orange clade (\"r1\") do not all coalesce before the last divergence event, causing incomplete lineage sorting.</p>"},{"location":"quick_guide/#ipcoal-and-msprime","title":"ipcoal and msprime\u00b6","text":"<p>Coalescent simulations in ipcoal are performed using function calls from msprime which stores results in the TreeSequence format implemented in tskit. We strive to keep ipcoal up to date with new versions of msprime and tskit and to implement requested features like new substitution models, rate maps, or demographic modelling functions. However, we do not aim to implement every feature of msprime, as that would be redundant. In ipcoal, users can also access <code>TreeSequence</code> objects as the result of simulations (see Interaction with tskit), but in our default setting these objects are discarded and only a summarized tabular result is stored. In this way, <code>ipcoal</code> should be viewed a complementary tool to msprime and tskit, not as a replacement. It relies heavily on these tools for simulations, however, ipcoal has an entirely separate code base for our data analysis tools (see Phylogenetic Inference and Likelihood).</p>"},{"location":"quick_guide/#simulation-functions","title":"Simulation functions\u00b6","text":"<p>An <code>ipcoal.Model</code> object has three methods for coalescent simulation, <code>sim_trees()</code>, <code>sim_loci()</code>, and <code>sim_snps</code> (see Simulation Functions). Each of these serves a different purpose, and accepts a number of arguments to modify its behavior. Under the hood, they represent different algorithm that make function calls in msprime. If you intend to set up highly complex simulations it may often be advantageous to perform your simulations in msprime directly, rather than using ipcoal. The main advantages of ipcoal come from the use of these functions, and from its more limited scope, and miminalist ethos, which make it easier to simulate and analyze data focused on phylogenetic trees (e.g., newick trees or sequence alignments).</p>"},{"location":"quick_guide/#sim_trees","title":"sim_trees\u00b6","text":"<p>The <code>sim_trees</code> function is the simplest and fastest simulation function. It generates only coalescent trees as a result, and does not perform mutations. It takes two arguments, <code>nloci</code> and <code>nsites</code>. In ipcoal we always treat loci as being independent of one another. You can think of them as separate chromosomes. The length of each locus is represented by some number of sites. To simulate completely unlinked genealogies we can request the genealogy from a single site (nsites=1) from multiple independent loci. If you set nsites &gt; 1, and the <code>Model</code>'s recombination rate is &gt;0, then recombination events can occur within a locus, giving rise to multiple linked genealogies  (i.e., known as a tree sequence or ARG).</p>"},{"location":"quick_guide/#sim_loci","title":"sim_loci\u00b6","text":"<p>The <code>sim_loci</code> function is a simple extension of the <code>sim_trees</code> function that adds mutations to the simulated trees using the mutation rate and substitution model stored to the <code>Model</code> object. If you are only interested in tree data then you should use <code>sim_trees</code>, whereas if you are interested in both trees and sequences then you should use this function.</p>"},{"location":"quick_guide/#sim_snps","title":"sim_snps\u00b6","text":"<p>The <code>sim_snps</code> function is the most complex. It is used to generate unlinked SNPs. This allows you to perform coalescent simulations with mutation while also conditioning on the observation of variation. There are several options that can be implemented in this function to affect how the conditioning works, which can be toggled to trade-off potential biases versus speed. Note that the speed of this function can be very slow if both the mutation rate and coalescent times of your trees are very small.</p>"},{"location":"quick_guide/#linked-genealogies","title":"Linked genealogies\u00b6","text":"<p>An important distinction that we highlight in ipcoal is whether you are simulating linked or unlinked data. Unlinked data represents independent draws from a distribution, whereas linked data represents correlated draws, meaning that the next data point is influenced by the previous one. In the context of a genome we expect that regions located on different chromosomes are independent of each other, whereas sites that are located close together on the same chromosome are not independent. In the context of the coalescent, the correlation among nearby regions of the genome represents that one or more samples shares the same ancestors in both regions. Recombination causes this similarity to decay since it has the effect of causing different genomic regions to trace back to different sampled ancestors. The ability to simulate correlated tree sequences over large genomic regions using algorithms that approximate the coalescent with recombination has opened many new opportunities for studying genome-wide genealogical patterns.</p> <p>There are instances where we may be interested in simulating linked data to study the effect of recombination, or alternatively, we may sometimes wish to simulate unlinked data. Many population genetic and phylogenetic inference tools assume that data are unlinked. One useful application of ipcoal is to generate linked and unlinked datasets to explore the effect of linkage on analytical results.</p>"},{"location":"quick_guide/#simulation-results","title":"Simulation results\u00b6","text":"<p>The results of a simulation function call are stored to the <code>Model</code> object. The main results are the <code>.df</code> dataframe and <code>.seqs</code> numpy array.</p>"},{"location":"quick_guide/#dataframe-df","title":"dataframe (.df)\u00b6","text":"<p>All simulation functions generate a <code>.df</code> dataframe as a result. This is a pandas DataFrame object that can be used to access the results. What does this tables show? You can see in the unlinked results table that 10 different loci are represented, numbered 0-9 in the \u201clocus\u201d column. Each locus is represented by only a single site, stretching from start=0 to end=1. Each is 1bp in length and contains no SNPs since we have not simulated sequence data yet, only genealogies. A column labeling the tree index (tidx) for each row shows that all are labeled 0, meaning that each genealogy is the first (and here only) tree simulated in that locus. Finally, the results of greatest interest are in the final column, genealogy, which contains newick strings.</p> <p>Now look at the linked results table. In contrast to the previous table we see that multiple rows correspond to each locus ID. The first genealogy stretches from position 0 (start=0) to position 3380 (end=3380) and it is 3380bp in length. Following down the table we can see that recombination has broken this locus into many small chunks each represented by a different sized chunk of the locus, and by a slightly different genealogy. Each genealogy has a different tree index (tidx) indicating their order along the locus.</p> <p>Of course it is hard to tell from the table how different these genealogies are. The next step is to use visualization tools and statistical analyses to compare trees.</p>"},{"location":"quick_guide/#sequences-seqs","title":"sequences (.seqs)\u00b6","text":"<p>The other major result of simulation is sequences. These are stored efficiently as a numpy array in the <code>.seqs</code> attribute of a <code>Model</code> class object. Users can interact with this array directly, or use a number of convenience functions. Most often, users will want to use the <code>write</code> functions to write data to a number of different formats, or to use tools for analyzing the sequence variation directly.</p>"},{"location":"quick_guide/#simulating-sequences","title":"Simulating sequences\u00b6","text":""},{"location":"quick_guide/#accessing-treesequences","title":"Accessing TreeSequences\u00b6","text":"<p>A demographic model provides the simplest</p> <p>TreeSequence objects can be very large in terms of memory usage. In general, <code>ipcoal</code> is intended</p>"},{"location":"quick_guide/#sequences","title":"Sequences\u00b6","text":""},{"location":"quick_guide/#dataframe-summary","title":"Dataframe summary\u00b6","text":""},{"location":"quicker_guide/","title":"Quick Guide","text":"In\u00a0[1]: Copied! <pre>import ipcoal\nimport toytree\n</pre> import ipcoal import toytree In\u00a0[2]: Copied! <pre># example initialization of a Model object\nipcoal.Model(Ne=1000, nsamples=5)\n</pre> # example initialization of a Model object ipcoal.Model(Ne=1000, nsamples=5) Out[2]: <pre>&lt;ipcoal.model.Model at 0x7f8ee7f5ce30&gt;</pre> In\u00a0[3]: Copied! <pre># setup a single-population demographic model\nmodel = ipcoal.Model(Ne=1000, nsamples=6, seed_trees=123)\n\n# simulate one genealogical tree under this model\nmodel.sim_trees(nloci=1, nsites=1)\n\n# draw the first genealogy embedded in the demographic model\nmodel.draw_demography(idx=0);\n</pre> # setup a single-population demographic model model = ipcoal.Model(Ne=1000, nsamples=6, seed_trees=123)  # simulate one genealogical tree under this model model.sim_trees(nloci=1, nsites=1)  # draw the first genealogy embedded in the demographic model model.draw_demography(idx=0); idx=0 Ne=1e+03 Tc=inf Tg=infp_3p_5p_0p_4p_1p_2node=0node=1node=2node=3node=4node=5node=6node=7node=8node=9node=10010002000 <p>As a slightly more complex example, we can next set up a simulation that involves population structure in the form of a species tree. Here, the <code>toytree</code> library becomes very helpful for creating or parsing tree data to create a ToyTree data object as input. In this example we create a random 4-tip tree with a root height of 1e5 generations.</p> In\u00a0[4]: Copied! <pre># define a species tree\nsptree = toytree.rtree.unittree(ntips=4, treeheight=1e5, seed=333)\n\n# draw the tree using width to show Ne\nsptree.draw(ts='p');\n</pre> # define a species tree sptree = toytree.rtree.unittree(ntips=4, treeheight=1e5, seed=333)  # draw the tree using width to show Ne sptree.draw(ts='p'); 0123456r0r1r2r3050000100000 <p>Let's now set up a <code>Model</code> that uses the above tree to define a species tree scenario. Here we enter this tree object as the <code>tree</code> argument, from which the divergence times between lineages will be parsed. We can set an Ne value to all branches, or set different Ne values to each. We can sample the same number of gene copies from each population, or set different numbers for each. The <code>nsamples</code> arg here is entered as a dict where the keys correspond to node indices or names from the tree shown above. Finally, we can simulate trees and draw the demography.</p> <p>You can hover your cursor over the visualization below to view additional information about each population interval in the demographic model. This will list values for interval's index ID, Ne value, and length in units of generations (t$_g$) and coalescent units (t$_c$). Here we can see by embedding the simulated genealogy into the species tree that incomplete lineages sorting occurred in several species tree intervals.</p> In\u00a0[5]: Copied! <pre># set up a demographic model using the species tree\nmodel = ipcoal.Model(tree=sptree, Ne=3e4, nsamples={0: 3, 1: 2, 2: 2, 3: 3}, seed_trees=123)\n\n# simulate one genealogy\nmodel.sim_trees(1)\n\n# draw the genealogy embedded in the species tree model\nmodel.draw_demography(idx=0);\n</pre> # set up a demographic model using the species tree model = ipcoal.Model(tree=sptree, Ne=3e4, nsamples={0: 3, 1: 2, 2: 2, 3: 3}, seed_trees=123)  # simulate one genealogy model.sim_trees(1)  # draw the genealogy embedded in the species tree model model.draw_demography(idx=0); idx=0 Ne=3e+04 Tc=1.67 Tg=1e+05idx=5 Ne=3e+04 Tc=0.556 Tg=3.3e+04idx=4 Ne=3e+04 Tc=0.556 Tg=3.3e+04idx=3 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=1 Ne=3e+04 Tc=0.556 Tg=3.3e+04idx=2 Ne=3e+04 Tc=0.556 Tg=3.3e+04idx=6 Ne=3e+04 Tc=0 Tg=0r0_1r0_0r0_2r1_0r1_1r2_0r2_1r3_0r3_1r3_2node=4node=5node=6node=13node=14node=0node=1node=10node=2node=3node=7node=8node=9node=15node=11node=12node=16node=17node=18050000100000150000 <p>More on demographic models</p> <p>See Demography and Species Trees for tips on translating branch lengths on empirical trees from units of absolute time or coalescent units to generations, and tips for setting more complex demography, such as varying Ne values, and admixture edges.</p> <p>sim_trees: The <code>sim_trees</code> function is the fastest method. It generates only coalescent trees as a result, and does not perform mutations. It takes two arguments, <code>nloci</code> and <code>nsites</code>. In ipcoal we always treat loci as being independent of one another. You can think of them as separate chromosomes. The length of each locus is represented by some number of sites. Recombination can occur within a locus giving rise to multiple genealogical histories (See Linked Genealogies). This function is generally used to sample distributions of genealogies given the demographic model for use in investigating methods related to the coalescent.</p> In\u00a0[6]: Copied! <pre># simulate a single genealogy (i.e., for 1 locus at one site)\nmodel.sim_trees()\n</pre> # simulate a single genealogy (i.e., for 1 locus at one site) model.sim_trees() In\u00a0[7]: Copied! <pre># simulate 10 independent loci each containing one genealogy\nmodel.sim_trees(nloci=10)\n</pre> # simulate 10 independent loci each containing one genealogy model.sim_trees(nloci=10) In\u00a0[8]: Copied! <pre># simulate 1 locus of len=10000. May contain multiple trees if recomb.\nmodel.sim_trees(nloci=1, nsites=1e4)\n</pre> # simulate 1 locus of len=10000. May contain multiple trees if recomb. model.sim_trees(nloci=1, nsites=1e4) <p>sim_loci: The <code>sim_loci</code> function is a simple extension of the <code>sim_trees</code> function that adds mutations to the simulated trees using the mutation rate and substitution model stored to the <code>Model</code> object. This method is used to generate sequence data of the requested locus length, including invariant sites, and is useful for investigating methods related to phylogenetic inference.</p> In\u00a0[9]: Copied! <pre># simulate 2 loci each 100bp in length\nmodel.sim_loci(nloci=2, nsites=100)\n</pre> # simulate 2 loci each 100bp in length model.sim_loci(nloci=2, nsites=100) <p>sim_snps: The <code>sim_snps</code> function is the most complex. It is used to generate the requested number of unlinked SNPs. In contrast to the previous function, this one conditions the simulations on the observation of variation. There are several options that can be implemented to affect how the conditioning works, which can be toggled to trade-off potential biases versus speed. Note that the speed of this function can be very slow if both the mutation rate and coalescent times of your trees are very small. This is useful for testing many types of methods that analyze SNP data.</p> In\u00a0[10]: Copied! <pre># simulate 5 unlinked SNPs\nmodel.sim_snps(nsnps=5)\n</pre> # simulate 5 unlinked SNPs model.sim_snps(nsnps=5) In\u00a0[11]: Copied! <pre># simulate 1 locus w/ recombination to create a TreeSequence\nmodel = ipcoal.Model(tree=sptree, Ne=2e4, nsamples=2, seed_trees=123, store_tree_sequences=True)\nmodel.sim_loci(nloci=2, nsites=10000)\nmodel.draw_tree_sequence(width=700);\n</pre> # simulate 1 locus w/ recombination to create a TreeSequence model = ipcoal.Model(tree=sptree, Ne=2e4, nsamples=2, seed_trees=123, store_tree_sequences=True) model.sim_loci(nloci=2, nsites=10000) model.draw_tree_sequence(width=700); 050000100000150000200000250000idx: 0 interval: (0 - 2869) tmrca: 178601.54idx: 1 interval: (2869 - 4883) tmrca: 213729.26idx: 2 interval: (4883 - 7246) tmrca: 178601.54idx: 3 interval: (7246 - 8018) tmrca: 160421.34idx: 4 interval: (8018 - 10000) tmrca: 160421.34p0-0p0-1p1-6p1-7p3-4p3-5p2-2p2-3id: 0 pos: 0 time: 154653 mtype: 0id: 1 pos: 1 time: 86411 mtype: 0id: 2 pos: 2 time: 3753 mtype: 0id: 3 pos: 3 time: 173180 mtype: 0id: 4 pos: 4 time: 30865 mtype: 0id: 5 pos: 5 time: 162635 mtype: 0id: 6 pos: 6 time: 101068 mtype: 0id: 7 pos: 7 time: 29071 mtype: 0id: 8 pos: 8 time: 63282 mtype: 0id: 9 pos: 9 time: 128495 mtype: 0id: 10 pos: 10 time: 27386 mtype: 0id: 11 pos: 11 time: 109022 mtype: 0id: 12 pos: 12 time: 110929 mtype: 0id: 13 pos: 13 time: 105087 mtype: 0id: 14 pos: 14 time: 114648 mtype: 0id: 15 pos: 15 time: 8973 mtype: 0id: 16 pos: 16 time: 102649 mtype: 0id: 17 pos: 17 time: 116823 mtype: 0id: 18 pos: 18 time: 39571 mtype: 0id: 19 pos: 19 time: 92026 mtype: 0p0-0p0-1p1-6p1-7p3-4p3-5p2-2p2-3id: 20 pos: 20 time: 18468 mtype: 0id: 21 pos: 21 time: 194301 mtype: 0id: 22 pos: 22 time: 106956 mtype: 0id: 23 pos: 23 time: 117613 mtype: 0id: 24 pos: 24 time: 100787 mtype: 0id: 25 pos: 25 time: 111982 mtype: 0id: 26 pos: 26 time: 118327 mtype: 0id: 27 pos: 27 time: 106821 mtype: 0id: 28 pos: 28 time: 8037 mtype: 0id: 29 pos: 29 time: 38649 mtype: 0id: 30 pos: 30 time: 52141 mtype: 0id: 31 pos: 31 time: 850 mtype: 0id: 32 pos: 32 time: 144092 mtype: 0id: 33 pos: 33 time: 5697 mtype: 0id: 34 pos: 34 time: 85294 mtype: 0id: 35 pos: 35 time: 434 mtype: 0id: 36 pos: 36 time: 53032 mtype: 0id: 37 pos: 37 time: 96624 mtype: 0p0-0p0-1p1-6p1-7p3-4p3-5p2-2p2-3id: 38 pos: 38 time: 5301 mtype: 0id: 39 pos: 39 time: 16389 mtype: 0id: 40 pos: 40 time: 7260 mtype: 0id: 41 pos: 41 time: 39686 mtype: 0id: 42 pos: 42 time: 124087 mtype: 0id: 43 pos: 43 time: 34408 mtype: 0p0-0p0-1p1-6p1-7p3-4p3-5p2-2p2-3id: 44 pos: 44 time: 90031 mtype: 0p0-0p0-1p1-6p1-7p2-3p2-2p3-4p3-5id: 45 pos: 45 time: 111514 mtype: 0id: 46 pos: 46 time: 4576 mtype: 0id: 47 pos: 47 time: 85434 mtype: 0id: 48 pos: 48 time: 88452 mtype: 0id: 49 pos: 49 time: 54455 mtype: 0id: 50 pos: 50 time: 34493 mtype: 0id: 51 pos: 51 time: 133758 mtype: 0id: 52 pos: 52 time: 45387 mtype: 0id: 53 pos: 53 time: 84257 mtype: 0id: 54 pos: 54 time: 54878 mtype: 0 <p>There are instances where you may be interested in simulating linked data to study the effect of recombination, or alternatively, we may sometimes wish to simulate unlinked data exclude it. Many population genetic and phylogenetic inference tools assume that data are unlinked. One useful application of ipcoal is to generate linked and unlinked datasets to explore the effect of linkage on analytical results.</p> <p>The technical way in which this is implemented in ipcoal is to simulate each locus as a distinct TreeSequence object. This can be seen in the code block below, where we use the optional argument <code>store_tree_sequences=True</code> to store the simulated TreeSequence objects to the <code>Model</code>. These can then be accessed from the <code>.ts_dict</code> attribute. Any two trees drawn from different TreeSequence objects (i.e., different loci) are independent. Any two trees drawn from the same TreeSequence (same locus) may be linked, depending on many factors of the demographic simulation.</p> In\u00a0[12]: Copied! <pre># simulating 5 loci generates 5 independent TreeSequences\nmodel = ipcoal.Model(tree=sptree, Ne=2e4, store_tree_sequences=True)\nmodel.sim_loci(nloci=5, nsites=1000)\nmodel.ts_dict\n</pre> # simulating 5 loci generates 5 independent TreeSequences model = ipcoal.Model(tree=sptree, Ne=2e4, store_tree_sequences=True) model.sim_loci(nloci=5, nsites=1000) model.ts_dict Out[12]: <pre>{0: &lt;tskit.trees.TreeSequence at 0x7f8ee0c29b50&gt;,\n 1: &lt;tskit.trees.TreeSequence at 0x7f8ee0b8a660&gt;,\n 2: &lt;tskit.trees.TreeSequence at 0x7f8ee0aa2f00&gt;,\n 3: &lt;tskit.trees.TreeSequence at 0x7f8ee0b500e0&gt;,\n 4: &lt;tskit.trees.TreeSequence at 0x7f8f783f7c80&gt;}</pre> <p>Does each locus contain only one genealogy, or can it contain multiple?</p> <p>If the recombination rate is &gt;0 then a single locus extending over more than one site can represent multiple coalescent genealogies, each separated by a recombination event that occurred in the history of the samples at that locus.</p> In\u00a0[13]: Copied! <pre># simulate unlinked genealogies\nmod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123)\nmod.sim_loci(nloci=10, nsites=1)\nmod.df\n</pre> # simulate unlinked genealogies mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123) mod.sim_loci(nloci=10, nsites=1) mod.df Out[13]: locus start end nbps nsnps tidx genealogy 0 0 0 1 1 0 0 (p_1:287537.351532411179... 1 1 0 1 1 0 0 (p_3:110157.870294456748... 2 2 0 1 1 0 0 ((p_0:1313.6091112858539... 3 3 0 1 1 0 0 (p_0:314684.858664838480... 4 4 0 1 1 0 0 (p_1:147864.053017845842... 5 5 0 1 1 0 0 (p_0:93326.6807769358565... 6 6 0 1 1 0 0 (p_3:143619.984664270363... 7 7 0 1 1 0 0 ((p_2:70699.778029327673... 8 8 0 1 1 0 0 ((p_0:14776.914259654118... 9 9 0 1 1 0 0 ((p_1:17689.798992805852... <p>Now look at an example linked data results table. In contrast to the previous table we see that multiple rows correspond to each locus ID. The first genealogy stretches from position 0 (start=0) to position 3380 (end=3380) and it is 3380bp in length. Following down the table we can see that recombination has broken locus 0 into many smaller intervals, each represented by a different sized chunk of the locus, and by a slightly different genealogy. Each genealogy has a different tree index (tidx) indicating their order along the locus.</p> In\u00a0[14]: Copied! <pre># simulate linked genealogies\nmod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123)\nmod.sim_loci(nloci=2, nsites=1e4)\nmod.df\n</pre> # simulate linked genealogies mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123) mod.sim_loci(nloci=2, nsites=1e4) mod.df Out[14]: locus start end nbps nsnps tidx genealogy 0 0 0 3380 3380 23 0 ((p_1:12194.366367953536... 1 0 3380 4888 1508 11 1 ((p_1:12194.366367953536... 2 0 4888 6243 1355 11 2 ((p_1:12194.366367953536... 3 0 6243 6811 568 4 3 (p_4:504559.306961862370... 4 0 6811 6910 99 0 4 ((p_1:12194.366367953536... 5 0 6910 6971 61 1 5 ((p_1:12194.366367953536... 6 0 6971 8463 1492 29 6 ((p_1:12194.366367953536... 7 0 8463 10000 1537 12 7 ((p_1:12194.366367953536... 8 1 0 7642 7642 22 0 ((p_2:13777.964596574553... 9 1 7642 7935 293 2 1 ((p_0:25416.063867531960... 10 1 7935 10000 2065 11 2 ((p_0:25416.063867531960... In\u00a0[15]: Copied! <pre># simulate 1 locus for 5 samples at 50 sites\nmod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123, subst_model=\"JC69\")\nmod.sim_loci(nloci=1, nsites=50)\nmod.seqs.shape\n</pre> # simulate 1 locus for 5 samples at 50 sites mod = ipcoal.Model(Ne=1e5, nsamples=5, seed_trees=123, subst_model=\"JC69\") mod.sim_loci(nloci=1, nsites=50) mod.seqs.shape Out[15]: <pre>(1, 5, 50)</pre> In\u00a0[16]: Copied! <pre># sequences are stored as a 3D array\nmod.seqs\n</pre> # sequences are stored as a 3D array mod.seqs Out[16]: <pre>array([[[0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0],\n        [0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0],\n        [0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0],\n        [0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0],\n        [0, 0, 0, 0, 3, 3, 1, 3, 3, 2, 0, 3, 0, 2, 2, 3, 0, 3, 2, 0, 0,\n         1, 2, 0, 0, 1, 2, 3, 2, 3, 3, 0, 3, 2, 1, 3, 3, 1, 2, 0, 2, 0,\n         3, 0, 1, 0, 0, 1, 1, 0]]], dtype=uint8)</pre> In\u00a0[17]: Copied! <pre># the mapping of ints to alleles\nmod.alleles\n</pre> # the mapping of ints to alleles mod.alleles Out[17]: <pre>{0: 'A', 1: 'C', 2: 'G', 3: 'T'}</pre> In\u00a0[18]: Copied! <pre># simulate sequences for 10 samples in population \nmodel = ipcoal.Model(sptree, Ne=1e5, nsamples=10, seed_trees=123, seed_mutations=123)\nmodel.sim_loci(nloci=100, nsites=100)\n</pre> # simulate sequences for 10 samples in population  model = ipcoal.Model(sptree, Ne=1e5, nsamples=10, seed_trees=123, seed_mutations=123) model.sim_loci(nloci=100, nsites=100) In\u00a0[19]: Copied! <pre># write .df dataframe to disk\nmodel.df.to_csv(\"/tmp/test.csv\")\n</pre> # write .df dataframe to disk model.df.to_csv(\"/tmp/test.csv\") In\u00a0[20]: Copied! <pre># write the full sequences to a file\nmodel.write_concat_to_phylip(name=\"test\", outdir=\"/tmp\", diploid=False)\n</pre> # write the full sequences to a file model.write_concat_to_phylip(name=\"test\", outdir=\"/tmp\", diploid=False) <pre>wrote concat locus (40 x 10000bp) to /tmp/test.phy\n</pre> In\u00a0[21]: Copied! <pre># write only the SNPs data to file\nmodel.write_vcf(name=\"test\", outdir=\"/tmp\", diploid=True)\n</pre> # write only the SNPs data to file model.write_vcf(name=\"test\", outdir=\"/tmp\", diploid=True) <pre>wrote 309 SNPs across 96 linkage blocks to /tmp/test.vcf\n</pre> In\u00a0[22]: Copied! <pre># get SNPs VCF as a dataframe\nvcf = model.write_vcf(diploid=True)\nvcf.head(10)\n</pre> # get SNPs VCF as a dataframe vcf = model.write_vcf(diploid=True) vcf.head(10) Out[22]: CHROM POS ID REF ALT QUAL FILTER INFO FORMAT r0_0 ... r2_0 r2_1 r2_2 r2_3 r2_4 r3_0 r3_1 r3_2 r3_3 r3_4 0 1 69 . A G 99 PASS . GT 1|0 ... 1|1 1|1 1|1 1|1 1|1 1|1 1|1 1|1 1|1 1|1 1 1 76 . T G 99 PASS . GT 0|0 ... 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 2 2 4 . A C 99 PASS . GT 0|0 ... 0|0 0|0 0|1 1|0 1|0 1|1 1|1 1|1 1|1 1|1 3 2 17 . T G 99 PASS . GT 0|0 ... 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 4 2 71 . G T 99 PASS . GT 0|0 ... 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 5 2 84 . A G 99 PASS . GT 1|0 ... 1|1 1|0 0|0 0|0 0|0 0|0 0|0 0|0 0|1 0|0 6 2 96 . C G 99 PASS . GT 0|0 ... 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 7 3 20 . G T 99 PASS . GT 0|0 ... 0|0 0|0 0|0 0|0 0|0 0|0 1|0 0|1 0|1 0|0 8 3 21 . A T 99 PASS . GT 0|0 ... 0|0 0|0 0|0 0|0 0|0 0|0 1|0 0|1 0|1 0|0 9 3 42 . A G 99 PASS . GT 0|0 ... 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 <p>10 rows \u00d7 29 columns</p> In\u00a0[23]: Copied! <pre>model = ipcoal.Model(sptree, Ne=1e4, nsamples=2, seed_trees=123)\nmodel.sim_trees(1)\nmodel.draw_demography(0);\n</pre> model = ipcoal.Model(sptree, Ne=1e4, nsamples=2, seed_trees=123) model.sim_trees(1) model.draw_demography(0); idx=0 Ne=1e+04 Tc=5 Tg=1e+05idx=5 Ne=1e+04 Tc=1.67 Tg=3.3e+04idx=4 Ne=1e+04 Tc=1.67 Tg=3.3e+04idx=3 Ne=1e+04 Tc=3.33 Tg=6.7e+04idx=1 Ne=1e+04 Tc=1.67 Tg=3.3e+04idx=2 Ne=1e+04 Tc=1.67 Tg=3.3e+04idx=6 Ne=1e+04 Tc=0 Tg=0r0_0r0_1r1_0r1_1r2_0r2_1r3_0r3_1node=0node=1node=8node=6node=7node=11node=4node=5node=10node=2node=3node=9node=12node=13node=14050000100000150000 <p>Genealogies: The <code>Model.draw_genealogies</code> function is a conventient tool for plotting a grid of multiple genealogies side by side on the same axis to compare their differences. It takes a number of options supported by the <code>toytree.Multitree.draw</code> function, which it calls under the hood.</p> In\u00a0[24]: Copied! <pre>model = ipcoal.Model(sptree, Ne=1e4, nsamples=2, seed_trees=123)\nmodel.sim_trees(10)\nmodel.draw_genealogies(scale_bar=1e4, shared_axes=True);\n</pre> model = ipcoal.Model(sptree, Ne=1e4, nsamples=2, seed_trees=123) model.sim_trees(10) model.draw_genealogies(scale_bar=1e4, shared_axes=True); r0_0r0_1r3_0r3_1r2_0r2_1r1_0r1_10510r0_0r0_1r3_0r3_1r1_0r1_1r2_0r2_10510r0_0r0_1r3_0r3_1r2_0r2_1r1_0r1_10510r0_0r0_1r2_0r2_1r1_0r1_1r3_0r3_10510 <p>Genealogy: The <code>Model.draw_genealogy</code> function is useful for selecting and plotting a single genealogy. It takes many optional styling arguments that are supported by <code>toytree.ToyTree.draw</code>. In addition, if you selected to <code>store_tree_sequences=True</code> during <code>Model</code> init then the placement of mutations on the edges of the genealogy can be shown as well by seting <code>show_substitutions=True</code>. The <code>idx</code> argument is used to select genealogies by index from the <code>Model.df</code> dataframe.</p> In\u00a0[25]: Copied! <pre>model = ipcoal.Model(sptree, Ne=1e4, nsamples=2, seed_trees=666, store_tree_sequences=True)\nmodel.sim_loci(1, 1e4)\nmodel.draw_genealogy(idx=0, show_substitutions=True);\n</pre> model = ipcoal.Model(sptree, Ne=1e4, nsamples=2, seed_trees=666, store_tree_sequences=True) model.sim_loci(1, 1e4) model.draw_genealogy(idx=0, show_substitutions=True); r0_0r0_1r3_0r3_1r1_0r1_1r2_0r2_1id: 0 site: 0 time: 36883 mtype: 0id: 1 site: 0 time: 21428 mtype: 0id: 2 site: 1 time: 27484 mtype: 0id: 3 site: 2 time: 20818 mtype: 0id: 4 site: 3 time: 47498 mtype: 0id: 5 site: 4 time: 23088 mtype: 0id: 6 site: 5 time: 34909 mtype: 0id: 7 site: 6 time: 53934 mtype: 0id: 8 site: 7 time: 116615 mtype: 0id: 9 site: 8 time: 3075 mtype: 0id: 10 site: 9 time: 96099 mtype: 0id: 11 site: 10 time: 60115 mtype: 0id: 12 site: 11 time: 17665 mtype: 0id: 13 site: 12 time: 48145 mtype: 0id: 14 site: 13 time: 78316 mtype: 0id: 15 site: 14 time: 52525 mtype: 0id: 16 site: 15 time: 11781 mtype: 0id: 17 site: 16 time: 14206 mtype: 0id: 18 site: 17 time: 33749 mtype: 0id: 19 site: 18 time: 25762 mtype: 0id: 20 site: 19 time: 71066 mtype: 0id: 21 site: 20 time: 10738 mtype: 0id: 22 site: 21 time: 2533 mtype: 0id: 23 site: 22 time: 63023 mtype: 0id: 24 site: 23 time: 20118 mtype: 0id: 25 site: 24 time: 35426 mtype: 0id: 26 site: 25 time: 18388 mtype: 012000080000400000tree in interval 0 (sites 0-4856) <p>TreeSequences: The <code>Model.draw_tree_sequence</code> function can be used to draw a tree sequence as an ordered set of trees and their interval lengths.</p> In\u00a0[26]: Copied! <pre># simulate 1 locus w/ recombination to create a TreeSequence\nmodel = ipcoal.Model(tree=sptree, Ne=2e4, nsamples=2, seed_trees=123, store_tree_sequences=1)\nmodel.sim_loci(nloci=2, nsites=10000)\nmodel.draw_tree_sequence(width=700);\n</pre> # simulate 1 locus w/ recombination to create a TreeSequence model = ipcoal.Model(tree=sptree, Ne=2e4, nsamples=2, seed_trees=123, store_tree_sequences=1) model.sim_loci(nloci=2, nsites=10000) model.draw_tree_sequence(width=700); 050000100000150000200000250000idx: 0 interval: (0 - 2869) tmrca: 178601.54idx: 1 interval: (2869 - 4883) tmrca: 213729.26idx: 2 interval: (4883 - 7246) tmrca: 178601.54idx: 3 interval: (7246 - 8018) tmrca: 160421.34idx: 4 interval: (8018 - 10000) tmrca: 160421.34p0-0p0-1p1-6p1-7p3-4p3-5p2-2p2-3id: 0 pos: 0 time: 154653 mtype: 0id: 1 pos: 1 time: 86411 mtype: 0id: 2 pos: 2 time: 3753 mtype: 0id: 3 pos: 3 time: 173180 mtype: 0id: 4 pos: 4 time: 30865 mtype: 0id: 5 pos: 5 time: 162635 mtype: 0id: 6 pos: 6 time: 101068 mtype: 0id: 7 pos: 7 time: 29071 mtype: 0id: 8 pos: 8 time: 63282 mtype: 0id: 9 pos: 9 time: 128495 mtype: 0id: 10 pos: 10 time: 27386 mtype: 0id: 11 pos: 11 time: 109022 mtype: 0id: 12 pos: 12 time: 110929 mtype: 0id: 13 pos: 13 time: 105087 mtype: 0id: 14 pos: 14 time: 114648 mtype: 0id: 15 pos: 15 time: 8973 mtype: 0id: 16 pos: 16 time: 102649 mtype: 0id: 17 pos: 17 time: 116823 mtype: 0id: 18 pos: 18 time: 39571 mtype: 0id: 19 pos: 19 time: 92026 mtype: 0p0-0p0-1p1-6p1-7p3-4p3-5p2-2p2-3id: 20 pos: 20 time: 18468 mtype: 0id: 21 pos: 21 time: 194301 mtype: 0id: 22 pos: 22 time: 106956 mtype: 0id: 23 pos: 23 time: 117613 mtype: 0id: 24 pos: 24 time: 100787 mtype: 0id: 25 pos: 25 time: 111982 mtype: 0id: 26 pos: 26 time: 118327 mtype: 0id: 27 pos: 27 time: 106821 mtype: 0id: 28 pos: 28 time: 8037 mtype: 0id: 29 pos: 29 time: 38649 mtype: 0id: 30 pos: 30 time: 52141 mtype: 0id: 31 pos: 31 time: 850 mtype: 0id: 32 pos: 32 time: 144092 mtype: 0id: 33 pos: 33 time: 5697 mtype: 0id: 34 pos: 34 time: 85294 mtype: 0id: 35 pos: 35 time: 434 mtype: 0id: 36 pos: 36 time: 53032 mtype: 0id: 37 pos: 37 time: 96624 mtype: 0p0-0p0-1p1-6p1-7p3-4p3-5p2-2p2-3id: 38 pos: 38 time: 5301 mtype: 0id: 39 pos: 39 time: 16389 mtype: 0id: 40 pos: 40 time: 7260 mtype: 0id: 41 pos: 41 time: 39686 mtype: 0id: 42 pos: 42 time: 124087 mtype: 0id: 43 pos: 43 time: 34408 mtype: 0p0-0p0-1p1-6p1-7p3-4p3-5p2-2p2-3id: 44 pos: 44 time: 90031 mtype: 0p0-0p0-1p1-6p1-7p2-3p2-2p3-4p3-5id: 45 pos: 45 time: 111514 mtype: 0id: 46 pos: 46 time: 4576 mtype: 0id: 47 pos: 47 time: 85434 mtype: 0id: 48 pos: 48 time: 88452 mtype: 0id: 49 pos: 49 time: 54455 mtype: 0id: 50 pos: 50 time: 34493 mtype: 0id: 51 pos: 51 time: 133758 mtype: 0id: 52 pos: 52 time: 45387 mtype: 0id: 53 pos: 53 time: 84257 mtype: 0id: 54 pos: 54 time: 54878 mtype: 0 <p>Sequences: Visualizing sequences is not hugely useful, but as a teaching and validation tool it is nice to have the option.</p> In\u00a0[27]: Copied! <pre>model = ipcoal.Model(sptree, Ne=1e4, nsamples=2, seed_trees=123)\nmodel.sim_snps(10)\nmodel.draw_seqview(width=250, show_text=True);\n</pre> model = ipcoal.Model(sptree, Ne=1e4, nsamples=2, seed_trees=123) model.sim_snps(10) model.draw_seqview(width=250, show_text=True); r0_0CCCGTCATCAr0_1CCTGTCATCAr1_0CTTGAGCTCAr1_1CTTGAGCTCAr2_0GTTGAGCGCTr2_1GTTGAGCTCTr3_0CTTTACCTCAr3_1CTTTACCTTA In\u00a0[28]: Copied! <pre># simulate many loci under the species tree model\nmod = ipcoal.Model(sptree, Ne=1e5, nsamples=4)\nmod.sim_loci(nloci=500, nsites=1000)\n</pre> # simulate many loci under the species tree model mod = ipcoal.Model(sptree, Ne=1e5, nsamples=4) mod.sim_loci(nloci=500, nsites=1000) In\u00a0[29]: Copied! <pre># infer a gene tree for all 500 loci concatenated\nconcat_tree = ipcoal.phylo.infer_raxml_ng_tree(mod, idxs=None, diploid=True)\nconcat_tree.draw();\n</pre> # infer a gene tree for all 500 loci concatenated concat_tree = ipcoal.phylo.infer_raxml_ng_tree(mod, idxs=None, diploid=True) concat_tree.draw(); r0_1r0_0r1_1r1_0r2_1r2_0r3_0r3_1 In\u00a0[30]: Copied! <pre># infer a gene tree from the first 10 loci concatenated\nconcat_tree = ipcoal.phylo.infer_raxml_ng_tree(mod, idxs=range(10), diploid=True)\nconcat_tree.draw();\n</pre> # infer a gene tree from the first 10 loci concatenated concat_tree = ipcoal.phylo.infer_raxml_ng_tree(mod, idxs=range(10), diploid=True) concat_tree.draw(); r2_1r3_1r3_0r1_0r1_1r0_1r0_0r2_0 In\u00a0[31]: Copied! <pre># get the example msc dataset (species tree, genealogies, imap)\nS, G, I = ipcoal.msc.get_test_data(nloci=100, seed=123)\n\n# draw the first genealogy embedded in the species tree\nipcoal.draw.draw_embedded_genealogy(S, G[0], I, container_blend=True);\n</pre> # get the example msc dataset (species tree, genealogies, imap) S, G, I = ipcoal.msc.get_test_data(nloci=100, seed=123)  # draw the first genealogy embedded in the species tree ipcoal.draw.draw_embedded_genealogy(S, G[0], I, container_blend=True); idx=5 Ne=1e+05 Tc=1 Tg=2e+05idx=3 Ne=1e+05 Tc=3 Tg=6e+05idx=4 Ne=1e+05 Tc=1 Tg=2e+05idx=2 Ne=1e+05 Tc=2 Tg=4e+05idx=0 Ne=1e+05 Tc=1 Tg=2e+05idx=1 Ne=1e+05 Tc=1 Tg=2e+05idx=6 Ne=1e+05 Tc=0 Tg=0A_0A_2A_1B_0B_1C_0D_0node=0node=1node=2node=7node=3node=4node=8node=5node=6node=9node=10node=11node=120250000500000750000 In\u00a0[32]: Copied! <pre># the imap dictionary is simply a mapping of species names to genealogy tip names\nI\n</pre> # the imap dictionary is simply a mapping of species names to genealogy tip names I Out[32]: <pre>{'A': ['A_0', 'A_1', 'A_2'], 'B': ['B_0', 'B_1'], 'C': ['C_0'], 'D': ['D_0']}</pre> In\u00a0[33]: Copied! <pre># calculate the loglikelihood of the first genealogy given the species tree\nipcoal.msc.get_msc_loglik(S, G[0], I)\n</pre> # calculate the loglikelihood of the first genealogy given the species tree ipcoal.msc.get_msc_loglik(S, G[0], I) Out[33]: <pre>80.28093312011262</pre> In\u00a0[34]: Copied! <pre># calculate the sum loglikelihood of all genealogies given the species tree\nipcoal.msc.get_msc_loglik(S, G, I)\n</pre> # calculate the sum loglikelihood of all genealogies given the species tree ipcoal.msc.get_msc_loglik(S, G, I) Out[34]: <pre>7973.467153781378</pre> <p>We can evaluate this dataset under several different model parameter settings to find the parameters that optimize the log likelihood. This is meant as a simple demonstration, see the Likelihood section for ways to write this to run much faster. Here we can see that the true model parameters, constant Ne=1e5, has the lowest negative sum log-likelihood score, showing that the data (coalescent times) are best fit by this model.</p> In\u00a0[35]: Copied! <pre>import pandas as pd\n\n# create a dataframe to fill over multiple Ne values\nne_values = [1e3, 5e3, 1e4, 5e4, 1e5, 5e5, 1e6, 5e6]\nloglik_data = pd.DataFrame(\n    index=range(len(ne_values)), \n    columns=[\"Ne\", \"sum_loglik\", \"true_model\"]\n)\n\n# iterate over Ne values to calculate sum loglik\nfor idx, val in enumerate(ne_values):\n    \n    # set the species tree Ne value\n    S.set_node_data(\"Ne\", default=val, inplace=True)\n\n    # store calculated sum loglik given this Ne\n    loglik_data.loc[idx] = val, ipcoal.msc.get_msc_loglik(S, G, I), val==1e5\n\n# show result as ints for readability\nloglik_data.astype(int)\n</pre> import pandas as pd  # create a dataframe to fill over multiple Ne values ne_values = [1e3, 5e3, 1e4, 5e4, 1e5, 5e5, 1e6, 5e6] loglik_data = pd.DataFrame(     index=range(len(ne_values)),      columns=[\"Ne\", \"sum_loglik\", \"true_model\"] )  # iterate over Ne values to calculate sum loglik for idx, val in enumerate(ne_values):          # set the species tree Ne value     S.set_node_data(\"Ne\", default=val, inplace=True)      # store calculated sum loglik given this Ne     loglik_data.loc[idx] = val, ipcoal.msc.get_msc_loglik(S, G, I), val==1e5  # show result as ints for readability loglik_data.astype(int) Out[35]: Ne sum_loglik true_model 0 1000 69542 0 1 5000 18522 0 2 10000 12440 0 3 50000 8207 0 4 100000 7973 1 5 500000 8419 0 6 1000000 8770 0 7 5000000 9683 0"},{"location":"quicker_guide/#quick-guide","title":"Quick Guide\u00b6","text":"<p>Welcome to the quick guide tutorial for ipcoal. This page is intended to introduce major concepts of coalescent simulations and to provide a concise overview of several types of statistical evolutionary analyses that can be performed in ipcoal. This documentation demonstrates ipcoal through a series of examples that combine analyses alongside visualizations, in the style of a jupyter notebook, where Python code can be executed interactively. The Python package toytree is installed alongside ipcoal and should typically be imported with it, like below, as the two are intended to work hand-in-hand.</p> <p>Follow along in this guide to learn how to set up a parameterized demographic model; simulate coalescent genealogies and sequences; calculate likelihoods of observed data; apply phylogenetic inference tools to sequences; and compare inferred gene trees to simulated genealogies. Explore the documentation to learn more details about each of these steps and explore other features of ipcoal.</p>"},{"location":"quicker_guide/#the-model-class","title":"The Model class\u00b6","text":"<p>A core concept in evolutionary genetics is the use of population demographic models to represent a set of simplifying assumptions about how gene copies are replicated and inherited from one generation to the next. The main object in ipcoal is the <code>ipcoal.Model</code> class object, which represents a parameterized population demographic model (see Model class). This object is initialized with a number of parameter arguments that define not only the demographic history, but also the model of substitution, and some other more detailed optional arguments about how simulations will be performed. Once the object is initialized, it can be used to call a number of associated methods, and to access information about the model and simulation results from a number of associated attributes.</p>"},{"location":"quicker_guide/#setting-demography","title":"Setting Demography\u00b6","text":"<p>The <code>tree</code> argument to the <code>Model</code> class is used to set up a demographic model. The simplest model is a single panmictic population with constant diploid effective population size (Ne). In ipcoal this can be initiated as a <code>Model</code> class with the default option of <code>tree=None</code>. In this case you only need to enter the <code>Ne</code> parameter, and set <code>nsamples</code> to designate the number of gene copies to simulate a genealogical history for. Throughout this documentation we will often set the <code>seed_trees</code> argument as well to set a random seed generator to ensure the same results each time.</p> <p>In the example below we initialize a Model and call two additional methods from this object. The key concept to understand here is that the genealogy (shown with green edges) represents one randomly sampled history for a set of six gene copies from this population. The visualization, which shows a gene tree embedded in a grey rectangle, represents an embedding of the genealogy within the demographic model (i.e., the model is a container within which the genealogy must fit). In this example the gene copies coalesce to a common ancestor a little over 2000 generations ago.</p>"},{"location":"quicker_guide/#simulation","title":"Simulation\u00b6","text":"<p>An <code>ipcoal.Model</code> object has three methods for coalescent simulation, <code>sim_trees()</code>, <code>sim_loci()</code>, and <code>sim_snps</code>. Each of these serves a different purpose, and accepts a number of arguments to modify its behavior. Under the hood, they represent different algorithms to make one or more function calls to msprime and store a summary of the results, and/or the full results as one or more <code>tskit.TreeSequence</code> objects. In many cases, the summarized results of ipcoal simulations (described below) are intended to provide a simpler minimalist interface to working with tree sequence simulations.</p>"},{"location":"quicker_guide/#tree-sequences-and-args","title":"Tree Sequences and ARGs\u00b6","text":"<p>An important distinction that we highlight in ipcoal is the difference between linked and unlinked genealogical data. Unlinked data represents independent draws from a distribution, whereas linked data represents correlated draws, meaning that the next data point is influenced by the previous one. In the context of a genome, we expect that regions located on different chromosomes are independent of each other, whereas sites that are located close together on the same chromosome are not. In the context of the coalescent, the correlation among nearby regions of the genome represents that one or more samples share the same ancestors in both regions. Recombination between regions causes this similarity to decay since it has the effect of causing different genomic regions to trace back to different ancestors.</p> <p>A simulated locus represents the genealogical history for the set of gene copies over the requested length of sites. The samples may share a single genealogy over the entire locus, or if recombination has occurred at a position in this locus throughout their history, then the gene copies will trace back &gt;1 linked genealogical histories. In that case, each genealogy will have a corresponding start and end position on the chromosome/locus. This data structure, composed of an ordered set of trees and their interval lengths, is termed an ancestral recombination graph (ARG), and can also be represented as a tree sequence (the term and structure used by msprime/tskit). Below is a visualization of an example tree sequence composed of a 10Kb locus in which the history for this set of samples is distributed across five different genealogies, each separated by recombination events that occurred in their history.</p>"},{"location":"quicker_guide/#simulation-results","title":"Simulation results\u00b6","text":"<p>As we saw above, it is possible to store and access <code>TreeSequence</code> objects as the result of simulation, from which a huge wealth of information can be extracted. However, in many cases it may be preferable to discard these and instead analyze a summary of the simulation, in terms of the trees and sequences that it produces. This is the default behavior of ipcoal, where calling one of the three simulation functions will generate two results stored to the Model object, a <code>.df</code> dataframe and a <code>.seqs</code> numpy array.</p>"},{"location":"quicker_guide/#dataframe-modeldf","title":"dataframe (Model.df)\u00b6","text":"<p>All simulation functions generate a <code>.df</code> dataframe as a result. This is a pandas DataFrame object that can be used to access the results. What does this table show? You can see in the example table from a simulation of unlinked data below that 10 different loci are represented, numbered 0-9 in the \u201clocus\u201d column. Each locus is represented by only a single site, stretching from start=0 to end=1. Each is 1bp in length and contains no SNPs since we have not simulated sequence data yet, only genealogies. A column labeling the tree index (tidx) for each row shows that all are labeled 0, meaning that each genealogy is the first (and here only) tree simulated in that locus. The final column, genealogy, contains newick strings.</p>"},{"location":"quicker_guide/#sequences-modelseqs","title":"sequences (Model.seqs)\u00b6","text":"<p>The other major result of simulations is sequences. Sequences are simulated by applying a mutation process over the edges of the simulated genealogies (using <code>msprime.sim_mutations</code> under the hood). These are stored as a numpy array in the <code>.seqs</code> attribute of a <code>Model</code> class object. Users can optionally interact with this array directly, but most often, they will want to use the <code>write</code> functions to write data to a number of different formats (see next section). The sequences are stored in an array of shape (nloci, nsamples, nsites) as uint8 integers where each integer corresponds to a character state in the <code>.alleles</code> dict, which is defined by the substitution model set during <code>Model</code> initialization.</p>"},{"location":"quicker_guide/#writing-data","title":"Writing data\u00b6","text":"<p>Simulated data can be saved to disk in a number of ways. The dataframe result can be saved as a CSV using pandas operations, like below. Sequence data can be similarly saved in a tabular format, but in most cases the reason for writing sequences will be to format them for an analysis tool. (Note: see Phylogenetic Inference methods section below for analyzing sequences without having to write sequence files). A number of methods are available from <code>Model</code> objects for writing sequences, including <code>write_vcf</code>, <code>write_concat_to_phylip</code>, and others methods you can explore which similarly start with <code>write_</code>.</p>"},{"location":"quicker_guide/#visualization","title":"Visualization\u00b6","text":"<p>As you have already seen, ipcoal includes a number of methods for visualization. Examples are listed below.</p> <p>Demography: The <code>Model.draw_demography</code> method can be used to visualize the demographic model as a container in which genealogies can be selected to be embedded. There are many styling options for this method that can be used to modify its look. This provides a useful tool for validating demographic models, for teaching, and for gaining an intuitive understanding of the effects of your model parameters.</p>"},{"location":"quicker_guide/#phylogenetic-inference","title":"Phylogenetic Inference\u00b6","text":"<p>The <code>ipcoal.phylo</code> module contains a number of functions for efficiently performing phylogenetic inference on simulated sequences. This includes functions that call <code>raxml-ng</code> for inference of gene trees from individual loci, sliding windows, or concatenated sequences of multiple loci. This module also includes functions for inferring species tree or networks from distributions of trees using <code>astral</code> or <code>SNaQ</code>. (These tools can be easily installed using <code>conda</code>.) In the example below we call <code>infer_raxml_ng_tree</code> to infer a gene tree from sequences of concatenated loci. Here we use the arguments <code>idxs</code> to select all or a subset of loci, and the argument <code>diploid</code> to specify that pairs of haploid samples should be joined together to form diploid sequences (reducing the number of samples in half). This efficient approach to simulating and testing phylogenetic inference methods makes it easy to explore the effects of concatenation/recombination, substitution models/homoplasy, demographic model parameters, phasing/diploid sequences, and many other factors on the accuracy of gene tree inference. See the documentation section on Phylogenetic Inference for more examples.</p>"},{"location":"quicker_guide/#coalescent-likelihoods","title":"Coalescent likelihoods\u00b6","text":"<p>As a statistical model for genealogical ancestry the coalescent provides two key purposes: First, it serves as a generative model to simulate genealogies as random variables given a population demographic model. We have seen many examples of this already. It provides the basis for us to study genetic variation as the mutational process integrated over a large amount of genealogical variation. The second utility of the coalescent model is as an analytical tool for evaluating observations. We can ask how likely is this model to have produced this genealogy given the model parameters? The likelihood calculation associated with this question is implemented in ipcoal in two subpackages, <code>ipcoal.msc</code> and <code>ipcoal.smc</code>, for analyses under the multispecies coalescent and sequentially Markov coalescent, respectively. Here we show a brief example. See the Likelihood section for more details.</p> <p>We need three things to calculate a likelihood, a species tree with Ne values set to each edge, a gene tree, and an imap dictionary (S, G, and I). Here we fetch an example dataset using the <code>ipcoal.msc.get_test_data</code> function, which will return a species tree, 100 simulated genealogies, and a dict mapping species tree tip labels to genealogy tip labels.</p>"},{"location":"simulation/","title":"Simulation and TreeSequences","text":"In\u00a0[1]: Copied! <pre>import ipcoal\nimport toytree\n</pre> import ipcoal import toytree In\u00a0[2]: Copied! <pre># define a 5-tip species tree demographic Model\nsptree = toytree.rtree.unittree(ntips=5, treeheight=1e6, seed=123)\nmodel = ipcoal.Model(sptree, nsamples=2, Ne=1e5, seed_trees=123, seed_mutations=123, store_tree_sequences=True)\n\n# draw an example embedded genealogy\nmodel.sim_trees(1)\nmodel.draw_demography(0);\n</pre> # define a 5-tip species tree demographic Model sptree = toytree.rtree.unittree(ntips=5, treeheight=1e6, seed=123) model = ipcoal.Model(sptree, nsamples=2, Ne=1e5, seed_trees=123, seed_mutations=123, store_tree_sequences=True)  # draw an example embedded genealogy model.sim_trees(1) model.draw_demography(0); idx=6 Ne=1e+05 Tc=1.67 Tg=3.3e+05idx=7 Ne=1e+05 Tc=1.67 Tg=3.3e+05idx=5 Ne=1e+05 Tc=1.67 Tg=3.3e+05idx=2 Ne=1e+05 Tc=3.33 Tg=6.7e+05idx=3 Ne=1e+05 Tc=3.33 Tg=6.7e+05idx=4 Ne=1e+05 Tc=3.33 Tg=6.7e+05idx=0 Ne=1e+05 Tc=1.67 Tg=3.3e+05idx=1 Ne=1e+05 Tc=1.67 Tg=3.3e+05idx=8 Ne=1e+05 Tc=0 Tg=0r0_0r0_1r1_0r1_1r2_0r2_1r3_0r3_1r4_0r4_1node=6node=7node=8node=9node=14node=4node=5node=13node=0node=1node=10node=2node=3node=11node=15node=16node=17node=12node=1804000008000001200000 In\u00a0[3]: Copied! <pre># simulate a single genealogy (i.e., for 1 locus at one site)\nmodel.sim_trees()\nmodel.df\n</pre> # simulate a single genealogy (i.e., for 1 locus at one site) model.sim_trees() model.df Out[3]: locus start end nbps nsnps tidx genealogy 0 0 0 1 1 0 0 (((r3_0:62053.8324608124... In\u00a0[4]: Copied! <pre># simulate five independent TreeSequences (each 1 site)\nmodel.sim_trees(nloci=5)\nmodel.df\n</pre> # simulate five independent TreeSequences (each 1 site) model.sim_trees(nloci=5) model.df Out[4]: locus start end nbps nsnps tidx genealogy 0 0 0 1 1 0 0 (((r3_0:62053.8324608124... 1 1 0 1 1 0 0 (((r2_0:103037.424419652... 2 2 0 1 1 0 0 (((r2_0:11784.2776233241... 3 3 0 1 1 0 0 (((r3_0:263096.624715134... 4 4 0 1 1 0 0 (((r1_0:668765.649524524... In\u00a0[5]: Copied! <pre># simulate 10 independent loci each containing one genealogy\nmodel.sim_trees(nloci=10)\nmodel.df\n</pre> # simulate 10 independent loci each containing one genealogy model.sim_trees(nloci=10) model.df Out[5]: locus start end nbps nsnps tidx genealogy 0 0 0 1 1 0 0 (((r3_0:62053.8324608124... 1 1 0 1 1 0 0 (((r2_0:103037.424419652... 2 2 0 1 1 0 0 (((r2_0:11784.2776233241... 3 3 0 1 1 0 0 (((r3_0:263096.624715134... 4 4 0 1 1 0 0 (((r1_0:668765.649524524... 5 5 0 1 1 0 0 (((r3_0:40820.5599872290... 6 6 0 1 1 0 0 (((r2_0:217213.222983922... 7 7 0 1 1 0 0 ((r3_0:174821.2644626926... 8 8 0 1 1 0 0 (((r4_0:153197.298592874... 9 9 0 1 1 0 0 (((r2_0:144026.443506229... <p>Wwhen <code>nsites</code> is greater than 1 and <code>recomb</code> is nonzero, there is an opportunity for recombination to break a locus into separate intervals with different genealogical histories, as in the example 10Kb locus below.</p> In\u00a0[6]: Copied! <pre># simulate 1 locus of len=1000. May contain multiple trees if recomb.\nmodel.sim_trees(nloci=1, nsites=1_000)\nmodel.df\n</pre> # simulate 1 locus of len=1000. May contain multiple trees if recomb. model.sim_trees(nloci=1, nsites=1_000) model.df Out[6]: locus start end nbps nsnps tidx genealogy 0 0 0 552 552 0 0 (((r4_0:52913.7662955324... 1 0 552 636 84 0 1 (((r4_0:52913.7662955324... 2 0 636 1000 364 0 2 (((r4_0:52913.7662955324... In\u00a0[7]: Copied! <pre># a genealogy stored with the default precision=14\nmodel.sim_trees(1, precision=14)\nmodel.df.genealogy[0]\n</pre> # a genealogy stored with the default precision=14 model.sim_trees(1, precision=14) model.df.genealogy[0] Out[7]: <pre>'(((r3_0:62053.83246081245306,r3_1:62053.83246081245306):898951.07965969515499,(r4_0:72932.80428663847852,r4_1:72932.80428663847852):888072.10783386905678):278636.08353009587154,((r2_0:152989.70899227279006,r2_1:152989.70899227279006):836161.27246919600293,(r0_0:656659.41277821129188,(r0_1:386750.85023718787124,(r1_0:75788.65763844538014,r1_1:75788.65763844538014):310962.19259874249110):269908.56254102342064):332491.56868325744290):250490.01418913470116);'</pre> In\u00a0[8]: Copied! <pre># a genealogy stored with the precision=0 (int values)\nmodel.sim_trees(1, precision=0)\nmodel.df.genealogy[0]\n</pre> # a genealogy stored with the precision=0 (int values) model.sim_trees(1, precision=0) model.df.genealogy[0] Out[8]: <pre>'(((r3_0:62054,r3_1:62054):898951,(r4_0:72933,r4_1:72933):888072):278636,((r2_0:152990,r2_1:152990):836161,(r0_0:656659,(r0_1:386751,(r1_0:75789,r1_1:75789):310962):269909):332492):250490);'</pre> In\u00a0[9]: Copied! <pre>%%timeit\nmodel.sim_trees(nloci=1000, nsites=100, nproc=4)\n</pre> %%timeit model.sim_trees(nloci=1000, nsites=100, nproc=4) <pre>2.29 s \u00b1 95.3 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> In\u00a0[10]: Copied! <pre>%%timeit\nmodel.sim_trees(nloci=1000, nsites=100, nproc=1)\n</pre> %%timeit model.sim_trees(nloci=1000, nsites=100, nproc=1) <pre>4.09 s \u00b1 233 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> <p>We can validate that the simulation returns the exact same trees regardless of the number of cores used for parallelization.</p> In\u00a0[11]: Copied! <pre># simulate trees using proc=2 and proc=4 and compare the results\nmodel.sim_trees(10, 10, nproc=2)\nnwk_proc2 = model.df.genealogy[3]\n\nmodel.sim_trees(10, 10, nproc=4)\nnwk_proc4 = model.df.genealogy[3]\n\nassert nwk_proc2 == nwk_proc4\n</pre> # simulate trees using proc=2 and proc=4 and compare the results model.sim_trees(10, 10, nproc=2) nwk_proc2 = model.df.genealogy[3]  model.sim_trees(10, 10, nproc=4) nwk_proc4 = model.df.genealogy[3]  assert nwk_proc2 == nwk_proc4 In\u00a0[12]: Copied! <pre>model.sim_trees(5, 10)\nmodel.df\n</pre> model.sim_trees(5, 10) model.df Out[12]: locus start end nbps nsnps tidx genealogy 0 0 0 10 10 0 0 (((r2_0:264683.059124009... 1 1 0 10 10 0 0 (((r2_0:239512.323652444... 2 2 0 10 10 0 0 (((r3_0:70368.4285205892... 3 3 0 10 10 0 0 (((r4_0:174626.986084489... 4 4 0 10 10 0 0 ((r4_0:479240.4714488410... In\u00a0[13]: Copied! <pre>model.sim_loci(5, 10)\nmodel.df\n</pre> model.sim_loci(5, 10) model.df Out[13]: locus start end nbps nsnps tidx genealogy 0 0 0 10 10 0 0 (((r2_0:264683.059124009... 1 1 0 10 10 0 0 (((r2_0:239512.323652444... 2 2 0 10 10 1 0 (((r3_0:70368.4285205892... 3 3 0 10 10 0 0 (((r4_0:174626.986084489... 4 4 0 10 10 0 0 ((r4_0:479240.4714488410... In\u00a0[14]: Copied! <pre># simulate 5 unlinked SNPs\nmodel.sim_snps(nsnps=5)\nmodel.df\n</pre> # simulate 5 unlinked SNPs model.sim_snps(nsnps=5) model.df Out[14]: locus start end nbps nsnps tidx genealogy 0 0 0 1 1 1 0 (((r2_0:29637.2437810995... 1 1 0 1 1 1 0 (r4_1:1923244.1055243662... 2 2 0 1 1 1 0 (((r3_0:197589.519103828... 3 3 0 1 1 1 0 (((r2_0:522052.928222848... 4 4 0 1 1 1 0 (((r3_0:52008.4828349061... <p>You can visualize the SNPs or write them to a file the same as other simulated sequence data.</p> In\u00a0[15]: Copied! <pre># write as VCF\nmodel.write_vcf()\n</pre> # write as VCF model.write_vcf() Out[15]: CHROM POS ID REF ALT QUAL FILTER INFO FORMAT r0_0 r0_1 r1_0 r1_1 r2_0 r2_1 r3_0 r3_1 r4_0 r4_1 0 1 1 . G T 99 PASS . GT 1|1 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 1 2 1 . G C 99 PASS . GT 0|0 0|0 0|0 0|0 0|0 0|0 1|1 1|1 1|1 0|0 2 3 1 . A C 99 PASS . GT 0|0 0|0 0|0 0|0 0|0 0|0 1|1 1|1 1|1 1|1 3 4 1 . A T 99 PASS . GT 0|0 0|0 0|0 0|0 0|0 0|0 0|0 0|0 1|1 1|1 4 5 1 . A T 99 PASS . GT 0|0 0|0 0|0 0|0 0|0 0|0 1|1 1|1 0|0 0|0 In\u00a0[16]: Copied! <pre># visualize SNPs matrix\nmodel.draw_seqview(width=150, show_text=True);\n</pre> # visualize SNPs matrix model.draw_seqview(width=150, show_text=True); r0_0TGAAAr0_1GGAAAr1_0GGAAAr1_1GGAAAr2_0GGAAAr2_1GGAAAr3_0GCCATr3_1GCCATr4_0GCCTAr4_1GGCTA In\u00a0[17]: Copied! <pre># simulate tri-allelic SNPs\nmodel.sim_snps(nsnps=5, min_alleles=3, max_alleles=None)\nmodel.draw_seqview(width=150, show_text=True);\n</pre> # simulate tri-allelic SNPs model.sim_snps(nsnps=5, min_alleles=3, max_alleles=None) model.draw_seqview(width=150, show_text=True); r0_0TCAGCr0_1TCAGCr1_0GCAGTr1_1ACAGTr2_0TGCATr2_1TGCATr3_0TCAGGr3_1TCGGGr4_0TAAGTr4_1TAAGT <p>By contrast, we may want to exclude any alleles that are not bi-allelic. This can be done by setting <code>max_alleles=2</code>.</p> In\u00a0[18]: Copied! <pre># simulate only bi-allelic SNPs\nmodel.sim_snps(nsnps=5, min_alleles=2, max_alleles=2)\nmodel.draw_seqview(width=150, show_text=True);\n</pre> # simulate only bi-allelic SNPs model.sim_snps(nsnps=5, min_alleles=2, max_alleles=2) model.draw_seqview(width=150, show_text=True); r0_0TGAAAr0_1GGAAAr1_0GGAAAr1_1GGAAAr2_0GGAAAr2_1GGAAAr3_0GCCATr3_1GCCATr4_0GCCTAr4_1GGCTA In\u00a0[19]: Copied! <pre>model.sim_snps(nsnps=5, min_mutations=1, max_mutations=1)\nmodel.draw_seqview(width=150, show_text=True);\n</pre> model.sim_snps(nsnps=5, min_mutations=1, max_mutations=1) model.draw_seqview(width=150, show_text=True); r0_0TGAAAr0_1GGAAAr1_0GGAAAr1_1GGAAAr2_0GGAAAr2_1GGAAAr3_0GCCATr3_1GCCATr4_0GCCTAr4_1GGCTA <p>For a more strange scenario, we could select only sites that are bi-allelic, and where more than one mutation occurred. This would require that two samples mutated to the same derived allele (homoplasy). You could imagine other similar scenarios that toggle the min and max args to achieve specific aims.</p> In\u00a0[20]: Copied! <pre>model.sim_snps(nsnps=5, min_alleles=2, max_alleles=2, min_mutations=2, max_mutations=2)\nmodel.draw_seqview(width=150, show_text=True);\n</pre> model.sim_snps(nsnps=5, min_alleles=2, max_alleles=2, min_mutations=2, max_mutations=2) model.draw_seqview(width=150, show_text=True); r0_0TGAACr0_1TGGACr1_0TTAAAr1_1TGAAAr2_0TGAAAr2_1TGAAAr3_0TTAACr3_1TTAGCr4_0AGAGCr4_1AGGGC <p>We can examine these simulations in more detail by accessing the TreeSequence objects from the <code>Model.tsdict</code> attribute, or by using visualization methods in ipcoal to draw mutations that arose during the simulation. For example, the drawing below shows the first SNP from above which differs in samples \"r4_0\" and \"r4_1\" from the other samples. This actually arose because all other samples contain the derived allele which arose convergently in both the \"r3\" lineage and in the ancestor of the \"(r1,r2)\" lineage. Interesting.</p> In\u00a0[21]: Copied! <pre># draw the genealogy and mutations of the first SNP\nmodel.draw_tree_sequence(idx=0);\n</pre> # draw the genealogy and mutations of the first SNP model.draw_tree_sequence(idx=0); 050000010000001500000idx: 0 interval: (0 - 1) tmrca: 1385149.65r4_0r4_1r3_0r3_1r2_0r2_1r1_0r1_1r0_0r0_1id: 0 pos: 0 time: 883703 mtype: 0id: 1 pos: 0 time: 360704 mtype: 0 In\u00a0[22]: Copied! <pre># get a mutated tree sequence and advance the RNGs \nts = model.get_tree_sequence(nsites=100)\nrepr(ts)\n</pre> # get a mutated tree sequence and advance the RNGs  ts = model.get_tree_sequence(nsites=100) repr(ts) Out[22]: <pre>'&lt;tskit.trees.TreeSequence object at 0x728b233ed070&gt;'</pre>"},{"location":"simulation/#simulation","title":"Simulation\u00b6","text":"<p>An <code>ipcoal.Model</code> object has three methods for coalescent simulation, <code>sim_trees</code>, <code>sim_loci</code>, and <code>sim_snps</code>. Each of these serves a different purpose, and accepts a number of arguments to modify its behavior. Under the hood, they represent different algorithms to make one or more function calls to msprime and store a summary of the results, and/or the full results as one or more tskit.TreeSequence objects. These methods were introduced briefly in the Quick Guide. Here we provide a more detailed description of their options.</p>"},{"location":"simulation/#demographic-model","title":"Demographic Model\u00b6","text":"<p>Throughout this page we will reuse the simple demographic Model object below, describing a species tree with 5 lineages, a root height of 1e6 generations, Ne=1e5 for each lineage, and two sampled genomes per lineage.</p>"},{"location":"simulation/#simulation-args","title":"Simulation args\u00b6","text":""},{"location":"simulation/#nloci","title":"nloci\u00b6","text":"<p>The two core arguments to the simulations function are <code>nloci</code> and <code>nsites</code>. The first describes the number of independent TreeSequences to simulate, the latter describes the length of each TreeSequence in sites. By default these should be int values, but can be entered using scientific notation to designate large values (e.g., 1e6). Note: If you do actually want to allow simulation events to occur at non int intervals you can set the argument <code>discrete_genome=False</code> during Model initialization.</p>"},{"location":"simulation/#nsites","title":"nsites\u00b6","text":"<p>The <code>nsites</code> argument sets the length of simulated TreeSequences, which can be thought of as the length of independent chromosomes. This can be set to small or large values &gt;=1. In fact, setting <code>nsites=1</code> can often be useful to simulate many independent loci that do not include recombination. This type of distribution -- a collection of unlinked genealogies -- is the typical assumption of the multispecies coalescent. By contrast, longer sequences can contain recombination such that they compose multiple linked genealogies.</p>"},{"location":"simulation/#precision","title":"precision\u00b6","text":"<p>The precision arg can be used to set the number of floating points used to store the height nodes when written to newick format. This is generally not very useful and users should leave it at its default value (14) to store high precision node heights. However, in some cases, such as very large trees, it may be useful to store less precise node heights in order to reduce the size of stored data.</p>"},{"location":"simulation/#nproc","title":"nproc\u00b6","text":"<p>When simulating trees there is an option to parallelize the simulation using multiple processors on a CPU. For very large simulations this can provide a reasonable speed improvement. This is currently only implemented for <code>sim_trees</code>. Note that this retains the repeatability of results using random seeds.</p>"},{"location":"simulation/#sim_trees","title":"sim_trees\u00b6","text":"<p>The <code>sim_trees</code> function is the fastest simulation method available. It generates only coalescent trees as a result, and does not perform mutations.</p>"},{"location":"simulation/#sim_loci","title":"sim_loci\u00b6","text":"<p>The <code>sim_loci</code> function is a simple extension of the <code>sim_trees</code> function that adds mutations to the simulated trees using the mutation rate and substitution model stored to the Model object. This method generate sequences, including invariant sites, that can be written using the <code>Model.write</code> methods, and is useful for investigating methods related to phylogenetic inference. Note that simulating sequences also involves simulated genealogies, and so this includes all information that is produced by <code>sim_trees</code> in addition to more information.</p>"},{"location":"simulation/#sim_snps","title":"sim_snps\u00b6","text":"<p>The <code>sim_snps</code> function is the most complex. It is used to generate the requested number of unlinked SNPs. In contrast to the previous function, this one conditions the simulations on the observation of variation. In other words, it will generate a TreeSequence, apply mutations to it, and if no mutations are observed, it samples a new TreeSequence (unless the <code>repeat_on_trees</code> arg is used; see below). This method includes several options that affect how the conditioning works, which can be toggled to trade-off potential biases versus speed. Note that the speed of this function can be very slow if both the mutation rate and coalescent times of your trees are very small. This is useful for testing many types of methods that analyze SNP data.</p>"},{"location":"simulation/#nsnps","title":"nsnps\u00b6","text":"<p>The purpose of this method is to sample unlinked snps, and so it only takes one argument, <code>nsnps</code>, to designate the size of the simulation, instead of <code>nloci</code> and <code>nsites</code>. Each simulated SNP will necessary occur on a different unlinked genealogy.</p>"},{"location":"simulation/#conditioning-on-snps","title":"Conditioning on SNPs\u00b6","text":"<p>When conditioning the simulation of SNPs, we must designate what we actually mean by this. Are we conditioning on the fact that samples must exhibit variation at the present, or that variation among samples existed at some point during the simulation? What if the a variant arose but then a subsequence mutation changed it back to its initial state such that variation existed for some time, but then was lost? What if multiple mutations occurred at a site so that it changed two or three times? We can simulate SNPs in ways that include or exclude these different scenarios by specifying the options to <code>min_mutations</code>, <code>max_mutations</code>, <code>min_alleles</code>, and <code>max_alleles</code>.</p>"},{"location":"simulation/#min-and-max-alleles","title":"min and max alleles\u00b6","text":"<p>By default <code>min_alleles=2</code>, and <code>max_alleles=None</code>. This means that a SNP must exhibit variation at the present to be kept (at least two alleles). However, multiple mutations can occur at the simulated site, we set no upper limit on the number of alleles. So we could observe a tri-allelic site. To demonstrate this, we can set <code>min_alleles=3</code> in the simulation below so that we only keep at least tri-allelic sites, where at least two mutations occurred. This simultion will surely take longer than the one above, since it is conditioning one a more rare scenario, however, since the Model describes a very deep simulation, many mutations occur giving rise to these results pretty quickly.</p>"},{"location":"simulation/#min-and-max-mutations","title":"min and max mutations\u00b6","text":"<p>Next, we can specify our conditioning in even more detail. For example, we may wish to simulate bi-allelic SNPs, but to exclude any that may represent a case in which an allele mutated to a different allele and then mutated back. Or where two different samples mutated the ancestral allele to the same derived allele (homoplasy). This can be set using <code>min_mutation</code> and <code>max_mutations</code>.</p>"},{"location":"simulation/#get_tree_sequence","title":"get_tree_sequence\u00b6","text":"<p>This function returns a mutated TreeSequence given the Model parameter settings. This is very similar to calling <code>sim_loci(1, nsites)</code>, but it does not spend the extra time to parse the newick tree and sequences to populate the <code>Model.df</code> and <code>Model.seqs</code> attributes. Thus, it is just a shortcut to calling <code>msprime.sim_ancestry</code> and <code>msprime.sim_mutations</code> given the parameter settings in the Model object. This can be useful and provide a great speedup when these summaries of the data are not needed. Note that this advances the <code>seed_trees</code> and <code>seed_mutations</code> RNGs of the Model object. It can be called many times given an initialized Model to return different TreeSequences starting from the initial seeds.</p>"},{"location":"species-tree-inference/","title":"Species tree inference","text":"In\u00a0[2]: Copied! <pre>import ipcoal\nimport toytree\nimport msprime\n</pre> import ipcoal import toytree import msprime <p>tldr;</p> <p>Call the `ipcoal.phylo.infer_astral_tree` method to infer a species tree using ASTRAL-III from a set of gene trees. This function will return the result as a ToyTree object with optional support values stored to the tree data. </p> In\u00a0[3]: Copied! <pre># get a 5-tip imbalanced species tree w/ equal internal edges\nsptree = toytree.rtree.unittree(ntips=5, treeheight=5e5, seed=123)\n\n# simulate 100 loci x 1000 sites under the demographic model\nmodel = ipcoal.Model(sptree, Ne=2e5, nsamples=4, seed_trees=123, seed_mutations=123)\nmodel.sim_loci(nloci=100, nsites=1000)\n\n# draw the demographic model with the first genealogy embedded\nmodel.draw_demography(idx=0, container_width=450);\n</pre> # get a 5-tip imbalanced species tree w/ equal internal edges sptree = toytree.rtree.unittree(ntips=5, treeheight=5e5, seed=123)  # simulate 100 loci x 1000 sites under the demographic model model = ipcoal.Model(sptree, Ne=2e5, nsamples=4, seed_trees=123, seed_mutations=123) model.sim_loci(nloci=100, nsites=1000)  # draw the demographic model with the first genealogy embedded model.draw_demography(idx=0, container_width=450); idx=6 Ne=2e+05 Tc=0.417 Tg=1.7e+05idx=7 Ne=2e+05 Tc=0.417 Tg=1.7e+05idx=5 Ne=2e+05 Tc=0.417 Tg=1.7e+05idx=2 Ne=2e+05 Tc=0.833 Tg=3.3e+05idx=3 Ne=2e+05 Tc=0.833 Tg=3.3e+05idx=4 Ne=2e+05 Tc=0.833 Tg=3.3e+05idx=0 Ne=2e+05 Tc=0.417 Tg=1.7e+05idx=1 Ne=2e+05 Tc=0.417 Tg=1.7e+05idx=8 Ne=2e+05 Tc=0 Tg=0r0_2r0_3r0_0r0_1r1_2r1_0r1_1r1_3r2_2r2_3r2_0r2_1r3_0r3_3r3_1r3_2r4_2r4_3r4_0r4_1node=12node=13node=14node=15node=27node=28node=29node=0node=1node=2node=11node=20node=16node=17node=18node=19node=31node=32node=33node=3node=4node=5node=6node=21node=22node=7node=8node=9node=10node=24node=25node=26node=30node=34node=23node=35node=36node=37node=380200000400000600000 In\u00a0[4]: Copied! <pre># show the first 10 trees in the result dataframe\nmodel.df.head(10)\n</pre> # show the first 10 trees in the result dataframe model.df.head(10) Out[4]: locus start end nbps nsnps tidx genealogy 0 0 0 333 333 14 0 (r1_2:605395.53255673300... 1 0 333 380 47 2 1 (r1_2:605395.53255673300... 2 0 380 478 98 4 2 (r1_2:605395.53255673300... 3 0 478 531 53 3 3 (r1_2:605395.53255673300... 4 0 531 826 295 18 4 (r1_2:605395.53255673300... 5 0 826 935 109 3 5 (r1_2:605395.53255673300... 6 0 935 951 16 1 6 (r1_2:605395.53255673300... 7 0 951 1000 49 2 7 (r1_2:605395.53255673300... 8 1 0 217 217 12 0 ((r3_0:544208.9382111437... 9 1 217 250 33 2 1 (((((r4_0:53193.45971929... <p>However, it is important to consider how these data actually match to the expectations of the multi-species coalescent. For example, if you simulate the coalescent with a recombination rate &gt; 0 for loci that are longer than 1 site in length, as we did here, then each locus may contain more than one genealogy. Indeed, we can see in the dataframe above that the first locus contains 8 genealogies. If we were to input all of these genealogies into ASTRAL it would technically violate an assumption of the MSC model that the trees are expected to be statistically independent. Instead, it would be more appropriate to sample one genealogy per locus, perhaps the first one, or the longest one. Below we extract the full set of genealogies, and a subset composing just one genealogy per locus. Here the trees are stored as a <code>pd.Series</code> object, which can be used in downstream steps, but it could just as well be a list or any collection object. We will analyze the trees in the next section.</p> In\u00a0[5]: Copied! <pre># get all simulated genealogies\nall_genealogies = model.df.genealogy\n</pre> # get all simulated genealogies all_genealogies = model.df.genealogy In\u00a0[6]: Copied! <pre># sample the first tree from every locus\nfirst_genealogies = model.df.genealogy[model.df.tidx == 0]\n</pre> # sample the first tree from every locus first_genealogies = model.df.genealogy[model.df.tidx == 0] <p>Using a multitree drawing from toytree we can view the first several simulated genealogies and see that there is some amount of ILS in each tree. We can see also that the trees are fully resolved and the tips align at zero. This is what simulated coalescent genealogies will usually look like.</p> In\u00a0[7]: Copied! <pre># draw the first four trees\ntoytree.mtree(first_genealogies).draw(shape=(1, 4), height=350);\n</pre> # draw the first four trees toytree.mtree(first_genealogies).draw(shape=(1, 4), height=350); r1_2r1_0r1_1r3_0r3_3r3_1r3_2r4_2r4_3r4_0r4_1r1_3r0_2r0_3r0_0r0_1r2_2r2_3r2_0r2_1r3_0r4_0r4_3r4_1r4_2r3_1r3_3r1_2r1_3r0_1r1_1r2_0r2_1r2_3r0_0r1_0r0_2r0_3r2_2r3_2r3_1r3_3r3_0r3_2r4_0r4_3r4_1r4_2r2_0r2_1r2_2r2_3r0_2r0_3r0_1r1_3r1_0r1_1r0_0r1_2r0_3r1_1r3_0r3_2r3_3r2_1r2_2r2_3r0_0r0_1r0_2r2_0r1_0r1_2r1_3r3_1r4_3r4_0r4_1r4_2 In\u00a0[8]: Copied! <pre># infer gene tree for each locus from 4 haploid samples\ngene_trees_haploid = ipcoal.phylo.infer_raxml_ng_trees(model, nboots=0, nthreads=4, nproc=2)\n</pre> # infer gene tree for each locus from 4 haploid samples gene_trees_haploid = ipcoal.phylo.infer_raxml_ng_trees(model, nboots=0, nthreads=4, nproc=2) In\u00a0[9]: Copied! <pre># infer gene tree for each locus from 2 diploid samples\ngene_trees_diploid = ipcoal.phylo.infer_raxml_ng_trees(model, diploid=True, nboots=0, nthreads=4, nproc=2)\n</pre> # infer gene tree for each locus from 2 diploid samples gene_trees_diploid = ipcoal.phylo.infer_raxml_ng_trees(model, diploid=True, nboots=0, nthreads=4, nproc=2) In\u00a0[10]: Copied! <pre>haploid_imap = model.get_imap_dict()\nhaploid_imap\n</pre> haploid_imap = model.get_imap_dict() haploid_imap Out[10]: <pre>{'r0': ['r0_0', 'r0_1', 'r0_2', 'r0_3'],\n 'r1': ['r1_0', 'r1_1', 'r1_2', 'r1_3'],\n 'r2': ['r2_0', 'r2_1', 'r2_2', 'r2_3'],\n 'r3': ['r3_0', 'r3_1', 'r3_2', 'r3_3'],\n 'r4': ['r4_0', 'r4_1', 'r4_2', 'r4_3']}</pre> In\u00a0[11]: Copied! <pre>diploid_imap = model.get_imap_dict(diploid=True)\ndiploid_imap\n</pre> diploid_imap = model.get_imap_dict(diploid=True) diploid_imap Out[11]: <pre>{'r0': ['r0_0', 'r0_1'],\n 'r1': ['r1_0', 'r1_1'],\n 'r2': ['r2_0', 'r2_1'],\n 'r3': ['r3_0', 'r3_1'],\n 'r4': ['r4_0', 'r4_1']}</pre> In\u00a0[12]: Copied! <pre># infer sptree from all genealogies (multiple linked trees per locus)\natree1 = ipcoal.phylo.infer_astral_tree(all_genealogies, imap=haploid_imap)\n</pre> # infer sptree from all genealogies (multiple linked trees per locus) atree1 = ipcoal.phylo.infer_astral_tree(all_genealogies, imap=haploid_imap) In\u00a0[13]: Copied! <pre># infer sptree from unlinked genealogies (1 per locus)\natree2 = ipcoal.phylo.infer_astral_tree(first_genealogies, imap=haploid_imap)\n</pre> # infer sptree from unlinked genealogies (1 per locus) atree2 = ipcoal.phylo.infer_astral_tree(first_genealogies, imap=haploid_imap) In\u00a0[21]: Copied! <pre># infer sptree from inferred gene trees haploid\natree3 = ipcoal.phylo.infer_astral_tree(gene_trees_haploid.gene_tree, imap=haploid_imap)\n</pre> # infer sptree from inferred gene trees haploid atree3 = ipcoal.phylo.infer_astral_tree(gene_trees_haploid.gene_tree, imap=haploid_imap) In\u00a0[23]: Copied! <pre># infer sptree from inferred gene trees diploid\natree4 = ipcoal.phylo.infer_astral_tree(gene_trees_diploid.gene_tree, imap=diploid_imap)\n</pre> # infer sptree from inferred gene trees diploid atree4 = ipcoal.phylo.infer_astral_tree(gene_trees_diploid.gene_tree, imap=diploid_imap) In\u00a0[29]: Copied! <pre>toytree.mtree([atree1, atree2, atree3, atree4]).root(\"r3\", \"r4\").draw();\n</pre> toytree.mtree([atree1, atree2, atree3, atree4]).root(\"r3\", \"r4\").draw(); r3r4r0r1r2r3r4r0r1r2r4r3r0r1r2r2r0r1r3r4"},{"location":"species-tree-inference/#species-tree-inference","title":"Species tree inference\u00b6","text":"<p>We currently implement a wrapper for the species tree inference tool astral3. This takes a set of trees as inputs, and thus provides a useful framework for comparing species trees inferred from true genealogies, versus a species tree inferred from error-prone gene trees. This method can be called from <code>ipcoal.phylo.infer_astral_tree</code>.</p>"},{"location":"species-tree-inference/#example-dataset","title":"Example dataset\u00b6","text":"<p>Here we set up a demographic model composing a species tree with 5 lineages r0-r4. The root node height is at 0.5M generations, and internal edges are set to equal lengths of ~166K generations. Each interval Ne is set to 2e5, which corresponds to an internal edge length of 0.42 coalescent units. As you can see in the visualization below, this corresponds to a small amount of ILS among the 4 sampled gene copies per lineage. We simulated 1000 loci each 1000 sites in length.</p>"},{"location":"species-tree-inference/#getting-tree-sets","title":"Getting tree sets\u00b6","text":""},{"location":"species-tree-inference/#genealogies","title":"Genealogies\u00b6","text":"<p>We can apply ASTRAL to infer a species tree from coalescent simulated data in a number of ways. First, we might be interested in the species tree that can be inferred from perfectly accurate input trees. We have these in the form of the simulated genealogies that are stored in the \"genealogy\" column of the <code>Model.df</code> dataframe.</p>"},{"location":"species-tree-inference/#gene-trees","title":"Gene trees\u00b6","text":"<p>We can also apply ASTRAL to infer a species tree from inferred gene trees. This is more similar to the analysis of real data, where gene trees may have unresolved nodes, variable branch lengths, and mismodeled substitutions rates (you could investigate other sources of error as well like missing samples or alignment errors.) Here we will use the ipcoal wrapper for raxml-ng to infer gene trees, but you could alternative use any method to infer trees that could then be loaded back in as ToyTrees from newick, nexus, or related text formats. A benefit of using the raxml wrapper in toytree is that we can easily automate the process of writing the sequence data, analyzing it, and loading back in the results. To keep things fast we do not estimate bootstrap supports for the gene trees here, but this can be easily added.</p>"},{"location":"species-tree-inference/#imap-dict","title":"IMAP dict\u00b6","text":"<p>When your data contains multiple individuals or gene copies per lineage it is typical to provide a mapping (imap) to tell the species tree inference software which genomes are members of the same lineage. This is entered to the <code>ipcoal.infer_astral_tree</code> method as a dictionary, where the keys are species tree tip names, and the values are lists of sample names that belong to that species. It is easy to extract an imap dict for simulations performed from an <code>ipcoal.Model</code> object by calling its <code>.get_imap_dict</code> function, which accepts are argument for whether or not pairs samples will be joined into diploid samples.</p>"},{"location":"species-tree-inference/#infer-species-trees","title":"Infer species trees\u00b6","text":"<p>See the ASTRAL III documentation for further details on options that can be run.</p>"},{"location":"species-tree-inference/#compare-species-trees","title":"Compare species trees\u00b6","text":"<p>In this case, all of the trees inferred the same species tree topology, which is not surprising since we simulated a pretty large dataset with a limited amount of ILS, which is a scenario where astral can be quite accurate. However, we can see that the different datasets have resulted in difference estimates of support and branch lengths (in coalescent units).</p>"},{"location":"terminology/","title":"Terminology and Units","text":""},{"location":"terminology/#scope","title":"Scope","text":"<p>In general we try to follow the terminology used by  msprime when referring to parameters that will be used in setting up and implementing coalescent simulation, such as the per-site per-generation mutation rate, admixture proportions, and diploid effective population sizes. </p>"},{"location":"terminology/#terminology","title":"Terminology","text":"<p>locus: a discrete sequence spanning 1 or more sites which may or may not  include intra-locus recombination. Each locus is simulated independently in ipcoal, as if each is a distinct chromosome.</p> <p>site: a single position on a chromosome/locus. Each simulated site on a  locus has a genealogical tree, and one genealogical tree can represent the history for multiple linked sites that represent an interval on a locus between recombination events. Note: A simulated site has a genealogical  tree history whether or not mutations/sequences are simulated.</p> <p>genealogy: the true ancestry of a set of sampled gene copies at some location in the genome. In a simulation framework, the genealogy is known,  but in the real world it is an unobservable variable that must be inferred from sequence variation.</p> <p>gene tree: the inferred ancestry of a set of sampled gene copies at some location in the genome, based on a sequence alignment. In practice, gene trees rarely match the true genealogy exactly since there is often insufficient  information (substitutions) within a small genomic region.</p> <p>species tree: a demographic model describing the topology (ancestral  relationships) and demographic parameters (e.g., Ne, divergence times, and admixture events) for one or more lineages. </p> <p>substitution model: a parameterized Markov model for the mutational process. A mutation causes a change from one discrete state in the mutation model to another. The probability of changes depend on the current state, the per-site per-generation mutation rate ($\\mu$), and the length of time over which a substitution can occur, repesented by the edges on a genealogy in units of generations. </p>"},{"location":"terminology/#units","title":"Units","text":"<p>genealogical branch lengths: defined in number of generations.  </p> <p>gene tree branch lengths: Depends on the inference method. If using the  default ML implementation in raxml-ng then gene tree branch lengths are in  units of expected number of substitutions per site.</p> <p>species tree branch lengths: defined in number of generations. Sometimes must be converted from coalescent units to generations, which requires only dividing by 2N if generation times are constant.</p> <p>generation: the length of time from birth until reproduction. Under the  Wright-Fisher process, which the coalescent approximates, generations do not overlap.   </p> <p>coalescent units: units of species tree branch lengths that describe the  probability that n samples coalesce over a length of time. It is calculated as (time in generations) / 2Ne for diploid populations.</p> <p>mutation rate: the expected number of mutations per site per generation.   </p> <p>recombination rate: the expected number of recombinations per site per generation.  </p> <p>admixture time: a time (absolute) or proportion along an edge (float between 0.0 and 1.0) defining the moment within an overlapping interval of two species tree edges that an admixture event occurred. (For example, if admixture  time=0.5, the event happens at the midpoint of the overlap between the two  branches). </p> <p>admixture proportion: the proportion of the source population that migrates to the destination population backwards in time (use visualization and  debugging methods to ensure the model is doing what you expect).</p>"},{"location":"theory_Kingman/","title":"theory Kingman","text":"In\u00a0[9]: Copied! <pre>import ipcoal\n</pre> import ipcoal In\u00a0[12]: Copied! <pre># setup a single-population demographic model\nmodel = ipcoal.Model(Ne=1000, nsamples=6, seed_trees=123)\n\n# simulate several independent genealogical histories under this model\nmodel.sim_trees(nloci=100, nsites=1)\n\n# draw the first genealogy embedded in the demographic model\nmodel.draw_demography(idx=0);\n</pre> # setup a single-population demographic model model = ipcoal.Model(Ne=1000, nsamples=6, seed_trees=123)  # simulate several independent genealogical histories under this model model.sim_trees(nloci=100, nsites=1)  # draw the first genealogy embedded in the demographic model model.draw_demography(idx=0); idx=0 Ne=1e+03 Tc=inf Tg=infp_3p_5p_0p_4p_1p_2node=0node=1node=2node=3node=4node=5node=6node=7node=8node=9node=10010002000 <p>The genealogy is different at each simulated locus. Because these loci are unlinked (uncorrelated) each represents a random draw from a distribution of trees described by the demographic model. You can see below that the genealogies of loci 1-4 are each quite different.</p> In\u00a0[7]: Copied! <pre>model.draw_genealogies(shape=(1, 4), shared_axes=True, scale_bar=True);\n</pre> model.draw_genealogies(shape=(1, 4), shared_axes=True, scale_bar=True); p_3p_5p_0p_4p_1p_2010002000p_2p_5p_0p_1p_3p_4010002000p_0p_1p_4p_3p_2p_5010002000p_0p_3p_1p_5p_2p_4010002000 In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"theory_Kingman/#kingman-coalescent","title":"Kingman coalescent\u00b6","text":"<p>The Kingman coalescent is a statistical model that describes the distribution of waiting times between coalescent events in a panmictic neutrally evolving population. This model has two major applications in evolutionary genetics. First, it provides a generative model by which to stochastically build genealogical trees by sampling waiting times between coalescent events. Given a parameterized model of population, minimally described by its effective population size (Ne), a distribution of genealogies</p> <p>By sampling many genealogies we can generate a distribution of genealogical histories given a parameterized model of a population. Secondly, the coalescent model is also important for serving as a probability density from which we can calculate the likelihood of one or more observed genealogies given a parameterized demographic model.</p>"},{"location":"theory_Kingman/#a-motivating-example","title":"A motivating example\u00b6","text":"<p>Given a population with effective size Ne=1000, imagine we have sampled sequences from 6 haploid genomes at 100 loci. Because the population is panmictic, we expect the average relationships among these genomes to be effectively randomly. Yet, at any exact position of their genomes they do share some precise genealogical history. For example, the drawing below shows the genealogy for the first locus, where samples <code>p_0</code> and <code>p_4</code> share a most recent common ancestor (mrca).</p>"},{"location":"theory_Kingman/#coalescent-times","title":"Coalescent times\u00b6","text":""},{"location":"theory_Kingman/#fitting-parameters","title":"Fitting parameters\u00b6","text":""},{"location":"theory_Kingman/#sequence-diversity","title":"Sequence Diversity\u00b6","text":""},{"location":"visualization/","title":"Visualizations","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport ipcoal\n</pre> import toytree import ipcoal In\u00a0[89]: Copied! <pre>sptree = toytree.rtree.unittree(ntips=5, treeheight=2e5, seed=123)\nsptree.set_node_data(\"Ne\", data={0:1e4, 1:2e4}, default=3e4, inplace=True)\nmodel = ipcoal.Model(sptree, store_tree_sequences=True)\nmodel.sim_loci(10, 1e4)\n</pre> sptree = toytree.rtree.unittree(ntips=5, treeheight=2e5, seed=123) sptree.set_node_data(\"Ne\", data={0:1e4, 1:2e4}, default=3e4, inplace=True) model = ipcoal.Model(sptree, store_tree_sequences=True) model.sim_loci(10, 1e4) In\u00a0[90]: Copied! <pre>model.draw_genealogy(idx=0);\n</pre> model.draw_genealogy(idx=0); r2r0r1r3r40100000200000 <p>All additional kwargs that can be passed to this function include any styling options that are supported by the toytree library for drawing trees (i.e., args to <code>ToyTree.draw</code>). Below are some examples.</p> In\u00a0[91]: Copied! <pre>model.draw_genealogy(idx=1, edge_widths=3, tip_labels_style={\"font-size\": 15}, height=275);\n</pre> model.draw_genealogy(idx=1, edge_widths=3, tip_labels_style={\"font-size\": 15}, height=275); r2r0r1r3r40100000200000 <p>Finally, the <code>show_substitutions</code> arg can be used to show mutations on each branch. This requires that the Model object was initialized with <code>store_tree_sequences=True</code> to store the mutation info. (This is currently very simple and does not take additional options to style the mutation markers. We hope to add more soon.)</p> In\u00a0[92]: Copied! <pre>model.draw_genealogy(idx=0, show_substitutions=True);\n</pre> model.draw_genealogy(idx=0, show_substitutions=True); r2r0r1r3r4id: 0 site: 0 time: 32612 mtype: 0id: 1 site: 1 time: 72280 mtype: 0id: 2 site: 2 time: 72165 mtype: 0id: 3 site: 3 time: 54406 mtype: 0id: 4 site: 4 time: 34091 mtype: 0id: 5 site: 5 time: 98673 mtype: 0id: 6 site: 6 time: 18800 mtype: 0id: 7 site: 7 time: 243164 mtype: 0id: 8 site: 8 time: 123045 mtype: 0id: 9 site: 9 time: 38407 mtype: 0id: 10 site: 10 time: 5531 mtype: 0id: 11 site: 11 time: 211227 mtype: 0id: 12 site: 12 time: 57020 mtype: 0id: 13 site: 13 time: 131837 mtype: 0id: 14 site: 14 time: 253638 mtype: 0id: 15 site: 15 time: 135760 mtype: 0id: 16 site: 16 time: 64254 mtype: 0id: 17 site: 17 time: 39753 mtype: 0id: 18 site: 18 time: 67136 mtype: 0id: 19 site: 19 time: 47002 mtype: 0id: 20 site: 20 time: 249808 mtype: 0id: 21 site: 21 time: 128078 mtype: 0id: 22 site: 22 time: 12532 mtype: 0id: 23 site: 23 time: 30 mtype: 0id: 24 site: 24 time: 43227 mtype: 0id: 25 site: 25 time: 123498 mtype: 0id: 26 site: 26 time: 26959 mtype: 0id: 27 site: 27 time: 136765 mtype: 0id: 28 site: 28 time: 2283 mtype: 0id: 29 site: 29 time: 69336 mtype: 0id: 30 site: 30 time: 253895 mtype: 0id: 31 site: 31 time: 93013 mtype: 0id: 32 site: 32 time: 102409 mtype: 0id: 33 site: 33 time: 129581 mtype: 0id: 34 site: 34 time: 245237 mtype: 0id: 35 site: 35 time: 238682 mtype: 0id: 36 site: 36 time: 57148 mtype: 02000001000000tree in interval 0 (sites 0-2909) In\u00a0[93]: Copied! <pre>model.draw_genealogies(idxs=[0, 1, 2, 3]);\n</pre> model.draw_genealogies(idxs=[0, 1, 2, 3]); r2r0r1r3r4r2r0r1r3r4r2r0r1r3r4r3r4r2r0r1 In\u00a0[94]: Copied! <pre>model.draw_genealogies(idxs=range(1, 5), shared_axes=True, scale_bar=True);\n</pre> model.draw_genealogies(idxs=range(1, 5), shared_axes=True, scale_bar=True); r2r0r1r3r40100000200000300000r2r0r1r3r40100000200000300000r3r4r2r0r10100000200000300000r3r4r2r0r10100000200000300000 In\u00a0[95]: Copied! <pre>model.draw_genealogies(idxs=range(4, 10), shape=(2, 3), shared_axes=True, scale_bar=1_000, height=400);\n</pre> model.draw_genealogies(idxs=range(4, 10), shape=(2, 3), shared_axes=True, scale_bar=1_000, height=400); r3r4r2r0r10100200300r3r4r2r0r10100200300r3r4r2r0r10100200300r3r4r2r0r10100200300r4r3r2r0r10100200300r4r3r2r0r10100200300 In\u00a0[96]: Copied! <pre>model.draw_cloud_tree();\n</pre> model.draw_cloud_tree(); r2r0r1r3r4 In\u00a0[97]: Copied! <pre>model.draw_cloud_tree(idxs=range(10, 20), edge_colors=\"darkcyan\", edge_style={\"stroke-opacity\": 0.1});\n</pre> model.draw_cloud_tree(idxs=range(10, 20), edge_colors=\"darkcyan\", edge_style={\"stroke-opacity\": 0.1}); r3r4r2r0r1 In\u00a0[98]: Copied! <pre>model.draw_sptree();\n</pre> model.draw_sptree(); 012345678r0r1r2r3r4050000100000150000200000 In\u00a0[101]: Copied! <pre>model.draw_demography();\n</pre> model.draw_demography(); idx=6 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=7 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=5 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=2 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=3 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=4 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=0 Ne=1e+04 Tc=3.33 Tg=6.7e+04idx=1 Ne=2e+04 Tc=1.67 Tg=6.7e+04idx=8 Ne=3e+04 Tc=0 Tg=0050000100000150000200000250000 In\u00a0[109]: Copied! <pre>model.draw_demography(idx=0);\n</pre> model.draw_demography(idx=0); idx=6 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=7 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=5 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=2 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=3 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=4 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=0 Ne=1e+04 Tc=3.33 Tg=6.7e+04idx=1 Ne=2e+04 Tc=1.67 Tg=6.7e+04idx=8 Ne=3e+04 Tc=0 Tg=0r0r1r2r3r4node=1node=2node=0node=3node=4node=5node=6node=7node=80100000200000300000 In\u00a0[112]: Copied! <pre>model.draw_demography(idx=13, container_blend=True);\n</pre> model.draw_demography(idx=13, container_blend=True); idx=6 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=7 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=5 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=2 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=3 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=4 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=0 Ne=1e+04 Tc=3.33 Tg=6.7e+04idx=1 Ne=2e+04 Tc=1.67 Tg=6.7e+04idx=8 Ne=3e+04 Tc=0 Tg=0r0r1r2r3r4node=1node=2node=0node=3node=4node=5node=6node=7node=80100000200000 <p>There are many additional styling arguments, but not all are fully tested together yet. Please provide feedback/requests.</p> In\u00a0[151]: Copied! <pre>model.draw_demography(\n    idx=0, \n    container_blend=True, container_width=500, container_height=300, \n    container_fill=\"red\", container_fill_opacity=0.4, container_fill_opacity_alternate=0.2, \n    container_root_height=50_000,\n    # container_interval_spacing=1000, container_interval_minwidth=1, container_interval_maxwidth=2,\n    # container_stroke=\"blue\", container_stroke_width=3, container_stroke_opacity=0.2,\n);\n</pre> model.draw_demography(     idx=0,      container_blend=True, container_width=500, container_height=300,      container_fill=\"red\", container_fill_opacity=0.4, container_fill_opacity_alternate=0.2,      container_root_height=50_000,     # container_interval_spacing=1000, container_interval_minwidth=1, container_interval_maxwidth=2,     # container_stroke=\"blue\", container_stroke_width=3, container_stroke_opacity=0.2, ); idx=6 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=7 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=5 Ne=3e+04 Tc=1.11 Tg=6.7e+04idx=2 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=3 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=4 Ne=3e+04 Tc=2.22 Tg=1.3e+05idx=0 Ne=1e+04 Tc=3.33 Tg=6.7e+04idx=1 Ne=2e+04 Tc=1.67 Tg=6.7e+04idx=8 Ne=3e+04 Tc=0 Tg=0r0r1r2r3r4node=1node=2node=0node=3node=4node=5node=6node=70100000200000 In\u00a0[104]: Copied! <pre>model.draw_tree_sequence(width=700);\n</pre> model.draw_tree_sequence(width=700); 0100000200000300000idx: 0 interval: (0 - 2909) tmrca: 259127.22idx: 1 interval: (2909 - 6500) tmrca: 239344.31idx: 2 interval: (6500 - 7628) tmrca: 217222.79idx: 3 interval: (7628 - 10000) tmrca: 217222.79r2r0r1r3r4id: 0 pos: 0 time: 32612 mtype: 0id: 1 pos: 1 time: 72280 mtype: 0id: 2 pos: 2 time: 72165 mtype: 0id: 3 pos: 3 time: 54406 mtype: 0id: 4 pos: 4 time: 34091 mtype: 0id: 5 pos: 5 time: 98673 mtype: 0id: 6 pos: 6 time: 18800 mtype: 0id: 7 pos: 7 time: 243164 mtype: 0id: 8 pos: 8 time: 123045 mtype: 0id: 9 pos: 9 time: 38407 mtype: 0id: 10 pos: 10 time: 5531 mtype: 0id: 11 pos: 11 time: 211227 mtype: 0id: 12 pos: 12 time: 57020 mtype: 0id: 13 pos: 13 time: 131837 mtype: 0id: 14 pos: 14 time: 253638 mtype: 0id: 15 pos: 15 time: 135760 mtype: 0id: 16 pos: 16 time: 64254 mtype: 0id: 17 pos: 17 time: 39753 mtype: 0id: 18 pos: 18 time: 67136 mtype: 0id: 19 pos: 19 time: 47002 mtype: 0id: 20 pos: 20 time: 249808 mtype: 0id: 21 pos: 21 time: 128078 mtype: 0id: 22 pos: 22 time: 12532 mtype: 0id: 23 pos: 23 time: 30 mtype: 0id: 24 pos: 24 time: 43227 mtype: 0id: 25 pos: 25 time: 123498 mtype: 0id: 26 pos: 26 time: 26959 mtype: 0id: 27 pos: 27 time: 136765 mtype: 0id: 28 pos: 28 time: 2283 mtype: 0id: 29 pos: 29 time: 69336 mtype: 0id: 30 pos: 30 time: 253895 mtype: 0id: 31 pos: 31 time: 93013 mtype: 0id: 32 pos: 32 time: 102409 mtype: 0id: 33 pos: 33 time: 129581 mtype: 0id: 34 pos: 34 time: 245237 mtype: 0id: 35 pos: 35 time: 238682 mtype: 0id: 36 pos: 36 time: 57148 mtype: 0r2r0r1r3r4id: 37 pos: 37 time: 97339 mtype: 0id: 38 pos: 38 time: 99445 mtype: 0id: 39 pos: 39 time: 131433 mtype: 0id: 40 pos: 40 time: 37175 mtype: 0id: 41 pos: 41 time: 131637 mtype: 0id: 42 pos: 42 time: 176721 mtype: 0id: 43 pos: 43 time: 49234 mtype: 0id: 44 pos: 44 time: 30535 mtype: 0id: 45 pos: 45 time: 233250 mtype: 0id: 46 pos: 46 time: 26206 mtype: 0id: 47 pos: 47 time: 88873 mtype: 0id: 48 pos: 48 time: 217749 mtype: 0id: 49 pos: 49 time: 74893 mtype: 0id: 50 pos: 50 time: 112323 mtype: 0id: 51 pos: 51 time: 131236 mtype: 0id: 52 pos: 52 time: 91650 mtype: 0id: 53 pos: 53 time: 36611 mtype: 0id: 54 pos: 54 time: 148524 mtype: 0id: 55 pos: 55 time: 96149 mtype: 0id: 56 pos: 56 time: 56399 mtype: 0id: 57 pos: 57 time: 69113 mtype: 0id: 58 pos: 58 time: 149248 mtype: 0id: 59 pos: 59 time: 56742 mtype: 0id: 60 pos: 60 time: 45730 mtype: 0id: 61 pos: 61 time: 221881 mtype: 0id: 62 pos: 62 time: 113827 mtype: 0id: 63 pos: 63 time: 219687 mtype: 0r2r0r1r3r4id: 64 pos: 64 time: 139681 mtype: 0id: 65 pos: 65 time: 115692 mtype: 0id: 66 pos: 66 time: 171448 mtype: 0id: 67 pos: 67 time: 79419 mtype: 0id: 68 pos: 68 time: 40531 mtype: 0r2r0r1r3r4id: 69 pos: 69 time: 15671 mtype: 0id: 70 pos: 70 time: 66924 mtype: 0id: 71 pos: 71 time: 59561 mtype: 0id: 72 pos: 72 time: 193274 mtype: 0id: 73 pos: 73 time: 204993 mtype: 0id: 74 pos: 74 time: 104134 mtype: 0id: 75 pos: 75 time: 87786 mtype: 0id: 76 pos: 76 time: 90513 mtype: 0id: 77 pos: 77 time: 99486 mtype: 0id: 78 pos: 78 time: 107559 mtype: 0id: 79 pos: 79 time: 82856 mtype: 0id: 80 pos: 80 time: 73403 mtype: 0id: 81 pos: 81 time: 1545 mtype: 0id: 82 pos: 82 time: 178176 mtype: 0id: 83 pos: 83 time: 210127 mtype: 0id: 84 pos: 84 time: 7045 mtype: 0id: 85 pos: 85 time: 71633 mtype: 0id: 86 pos: 86 time: 56630 mtype: 0id: 87 pos: 87 time: 27898 mtype: 0id: 88 pos: 88 time: 20612 mtype: 0id: 89 pos: 89 time: 84847 mtype: 0id: 90 pos: 90 time: 119200 mtype: 0id: 91 pos: 91 time: 161112 mtype: 0 In\u00a0[107]: Copied! <pre>model.draw_seqview(idx=0, start=0, end=200, show_text=True);\n</pre> model.draw_seqview(idx=0, start=0, end=200, show_text=True); r0AGGTAGTCAATCTCGATGTATCAGGCACTGTCCGGAATCCCTGACGAGGAGCCTAGTAGCCTCATATCATCTAAAATTGCACGGCAAGCTGTAGACCAACCGAGGACGTTGACCTGATTCAACGACGCTTGTTTCATGGTACAGCGTTCCAGAGCAGCTCGAGGATGCTCATACTTAAGCAGGCTCGCTTGAATATTCTGr1AGGTAGTCAATCTCGATGTATCAGGCACTGTCCGGAATCCCTGACGAGGAGCCTAGTAGCCTCATATCATCTAAAATTGCACGGCAAGCTGTAGACCAACCGAGGACGTTGACCTGATTCAACGACGCTTGTTTCATGGTACAGCGTTCCAGAGCAGCTCGAGGATGCTCATACTTAAGCAGGCTCGCTTGAATATTCAGr2AGGTAGTCAATCTCGATGTATCAGGCACTGTCCGGAATCCCTGACGAGGAGCCTAGTAGCCTCATATCATCTAAAATTGCACGGCAAGCTGTAGACCAACCGAGGACGTTGACCTGATTCAACGACGCTTGTTTCATGGTACAGCGTTCCAGAGCAGCTCGAGGATGCTCATACTTAAGCAGGCTCGCTTGAATATTCTGr3AGGTAGTCAATCTCGAGGTATCAGGCACTGTCCGGAATCCCTGACGAGGAGCCTAGTAGCCTCATATCATCTAAAATTGCACGGCAAGCTGTAGACCAACCGAGGACGTTGACCTGATTCAACGACGCTTGTTTCATGGTACAGCGTTCCAGAGCAGTTCGAGGATGCTCATACTTAAGCAGGCTCGCTTGAATATTCTGr4AGGTAGTCAATCTCGATGTATCAGGCACTGTCCGGAATCCCTGACGAGGAGCCTAGTAGCCTCATATCATCTAAAATTGCACGGCAAGCTGTAGACCAACCGAGGACGTTGACCTGATTCAACGACGCTTGTTTCATGGTACAGCGTTCCAGAGCAGCTCGAGGATGCTCATACTTAAGCAGGCTCGCTTGAATATTCTG In\u00a0[4]: Copied! <pre>S, G, I = ipcoal.msc.get_test_data(nloci=10, nsites=1, seed=123)\nipcoal.draw.draw_embedded_genealogy(S, G[0], I);\n</pre> S, G, I = ipcoal.msc.get_test_data(nloci=10, nsites=1, seed=123) ipcoal.draw.draw_embedded_genealogy(S, G[0], I); idx=5 Ne=1e+05 Tc=1 Tg=2e+05idx=3 Ne=1e+05 Tc=3 Tg=6e+05idx=4 Ne=1e+05 Tc=1 Tg=2e+05idx=2 Ne=1e+05 Tc=2 Tg=4e+05idx=0 Ne=1e+05 Tc=1 Tg=2e+05idx=1 Ne=1e+05 Tc=1 Tg=2e+05idx=6 Ne=1e+05 Tc=0 Tg=0A_0A_2A_1B_0B_1C_0D_0node=0node=1node=2node=7node=3node=4node=8node=5node=6node=9node=10node=11node=120250000500000750000"},{"location":"visualization/#visualization","title":"Visualization\u00b6","text":"<p>Throughout this documentation you have likely seen many examples of visualizations. Here we explain the options for each of these in greater detail.</p>"},{"location":"visualization/#test-dataset","title":"Test dataset\u00b6","text":"<p>Simulate sequence data for a 5-tip species tree scenario.</p>"},{"location":"visualization/#draw_genealogy","title":"draw_genealogy\u00b6","text":"<p>The <code>draw_genealogy</code> method takes two unique arguments, <code>idx</code> and <code>show_substitutions</code>, as well as a large set of optional arguments that can be passed as kwargs (described below). The <code>idx</code> argument selects the genealogy from the <code>Model.df</code> simulation table, where each simulated genealogy has a unique index in the table. This provides a simple and convenient shortcut to select a newick string from the Model.df table, load it as a ToyTree, and draw it.</p>"},{"location":"visualization/#draw_genealogies","title":"draw_genealogies\u00b6","text":"<p>Similar to how the function above selects a single genealogy and draws it as a ToyTree, this method loads a set of multiple newick strings and draws them as a <code>toytree.MultiTree</code> drawing. Thus, it accepts any kwargs accepted by <code>toytree.Multitree.draw</code>. This is used to draw a grid of multiple trees on separate or shared axes.</p>"},{"location":"visualization/#draw_cloud_tree","title":"draw_cloud_tree\u00b6","text":""},{"location":"visualization/#draw_sptree","title":"draw_sptree\u00b6","text":"<p>This is similar to the toytree method ...</p>"},{"location":"visualization/#draw_demography","title":"draw_demography\u00b6","text":""},{"location":"visualization/#draw_tree_sequence","title":"draw_tree_sequence\u00b6","text":""},{"location":"visualization/#draw_seqview","title":"draw_seqview\u00b6","text":""},{"location":"visualization/#draw_embedded_genealogy","title":"draw_embedded_genealogy\u00b6","text":"<p>The method <code>draw_embedded_genealogy</code> is similar to <code>Model.draw_demography</code> but does not require that you create a Model object. Instead, given a species tree, genealogy, and mapping of genealogy tips to species tree lineages, you can draw an embedding.</p>"},{"location":"cookbooks/cookbook-gentime-empirical/","title":"1. Generation time variation","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport ipcoal\nimport toytree\nimport toyplot\ncolormap = toyplot.color.brewer.map(\"BlueRed\", reverse=True)\n</pre> import numpy as np import pandas as pd import ipcoal import toytree import toyplot colormap = toyplot.color.brewer.map(\"BlueRed\", reverse=True) In\u00a0[2]: Copied! <pre># load the phylogenetic data (big tree, takes a few seconds)\nTREE_URL = (\n    \"https://github.com/eaton-lab/ipcoal/blob/master/\"\n    \"notebooks/mammal_dat/MamPhy_fullPosterior_BDvr_DNAonly\"\n    \"_4098sp_topoFree_NDexp_MCC_v2_target.tre?raw=true\"\n)\ntree = toytree.tree(TREE_URL)\nprint(tree.ntips, \"tips in the Upham mammal tree\")\n</pre> # load the phylogenetic data (big tree, takes a few seconds) TREE_URL = (     \"https://github.com/eaton-lab/ipcoal/blob/master/\"     \"notebooks/mammal_dat/MamPhy_fullPosterior_BDvr_DNAonly\"     \"_4098sp_topoFree_NDexp_MCC_v2_target.tre?raw=true\" ) tree = toytree.tree(TREE_URL) print(tree.ntips, \"tips in the Upham mammal tree\") <pre>4100 tips in the Upham mammal tree\n</pre> In\u00a0[3]: Copied! <pre># load the mammal biological data (e.g., geo range)\nPANTH_URL = (\n    \"https://github.com/eaton-lab/ipcoal/blob/master/\"\n    \"notebooks/mammal_dat/PanTHERIA_1-0_WR05_Aug2008.txt?raw=true\"\n)\npanthdf = pd.read_csv(PANTH_URL, sep='\\t')\nprint(panthdf.shape[0], \"taxa in PanTHERIA database\")\n</pre> # load the mammal biological data (e.g., geo range) PANTH_URL = (     \"https://github.com/eaton-lab/ipcoal/blob/master/\"     \"notebooks/mammal_dat/PanTHERIA_1-0_WR05_Aug2008.txt?raw=true\" ) panthdf = pd.read_csv(PANTH_URL, sep='\\t') print(panthdf.shape[0], \"taxa in PanTHERIA database\") <pre>5416 taxa in PanTHERIA database\n</pre> In\u00a0[4]: Copied! <pre># load the generation time data\nGT_URL = (\n    \"https://github.com/eaton-lab/ipcoal/blob/master/\"\n    \"notebooks/mammal_dat/5734-SP-2-Editor.csv?raw=true\"\n)\ngentimedf = pd.read_csv(GT_URL)\nprint(gentimedf.shape[0], \"taxa in Pacifici gentime database\")\n</pre> # load the generation time data GT_URL = (     \"https://github.com/eaton-lab/ipcoal/blob/master/\"     \"notebooks/mammal_dat/5734-SP-2-Editor.csv?raw=true\" ) gentimedf = pd.read_csv(GT_URL) print(gentimedf.shape[0], \"taxa in Pacifici gentime database\") <pre>5427 taxa in Pacifici gentime database\n</pre> In\u00a0[5]: Copied! <pre># subselect species names and geo range columns from pantheria\nsppdata = panthdf.loc[:, ['MSW05_Binomial', '26-1_GR_Area_km2']]\n\n# rename sppdata columns\nsppdata.columns = [\"species\", \"georange\"]\n</pre> # subselect species names and geo range columns from pantheria sppdata = panthdf.loc[:, ['MSW05_Binomial', '26-1_GR_Area_km2']]  # rename sppdata columns sppdata.columns = [\"species\", \"georange\"] In\u00a0[6]: Copied! <pre># make column to record tree tip label names\nsppdata[\"treename\"] = np.nan\n\n# dict map: {gen}_{spp} to {gen}_{spp}_{fam}_{order}\ntipdict = {i.rsplit(\"_\", 2)[0]: i for i in tree.get_tip_labels()}\n\n# record whether species in pantheria is in the tree tip labels\nfor idx in sppdata.index:\n\n    # match data names to tree names which have underscores\n    name = sppdata.species[idx]\n    name_ = name.replace(\" \", \"_\")\n\n    # record treename if it is in the database\n    if name_ in tipdict:\n        sppdata.loc[idx, \"treename\"] = tipdict[name_]\n</pre> # make column to record tree tip label names sppdata[\"treename\"] = np.nan  # dict map: {gen}_{spp} to {gen}_{spp}_{fam}_{order} tipdict = {i.rsplit(\"_\", 2)[0]: i for i in tree.get_tip_labels()}  # record whether species in pantheria is in the tree tip labels for idx in sppdata.index:      # match data names to tree names which have underscores     name = sppdata.species[idx]     name_ = name.replace(\" \", \"_\")      # record treename if it is in the database     if name_ in tipdict:         sppdata.loc[idx, \"treename\"] = tipdict[name_] In\u00a0[7]: Copied! <pre># add gentime values to all species matching to names in Pacifici data set\nsppdata[\"gentime\"] = np.nan\nfor idx in gentimedf.index:\n\n    # get generation time in units of years\n    species, gent = gentimedf.loc[idx, [\"Scientific_name\", \"GenerationLength_d\"]]\n    mask = sppdata.species == species\n    sppdata.loc[mask.values, \"gentime\"] = gent / 365.\n</pre> # add gentime values to all species matching to names in Pacifici data set sppdata[\"gentime\"] = np.nan for idx in gentimedf.index:      # get generation time in units of years     species, gent = gentimedf.loc[idx, [\"Scientific_name\", \"GenerationLength_d\"]]     mask = sppdata.species == species     sppdata.loc[mask.values, \"gentime\"] = gent / 365. In\u00a0[8]: Copied! <pre># set missing data (-999) to NaN\nsppdata[sppdata == -999.000] = np.nan\n\n# remove rows where either georange or gentime is missing\nmask = sppdata.georange.notna() &amp; sppdata.gentime.notna() &amp; sppdata.treename.notna()\nsppdata = sppdata.loc[mask, :]\n\n# reorder and reset index for dropped rows\nsppdata.sort_values(by=\"species\", inplace=True)\nsppdata.reset_index(drop=True, inplace=True)\n\n# show first ten sorted rows\nsppdata.head(10)\n</pre> # set missing data (-999) to NaN sppdata[sppdata == -999.000] = np.nan  # remove rows where either georange or gentime is missing mask = sppdata.georange.notna() &amp; sppdata.gentime.notna() &amp; sppdata.treename.notna() sppdata = sppdata.loc[mask, :]  # reorder and reset index for dropped rows sppdata.sort_values(by=\"species\", inplace=True) sppdata.reset_index(drop=True, inplace=True)  # show first ten sorted rows sppdata.head(10) Out[8]: species georange treename gentime 0 Abeomelomys sevia 53261.73 Abeomelomys_sevia_MURIDA... 1.710684 1 Abrocoma bennettii 54615.98 Abrocoma_bennettii_ABROC... 2.829928 2 Abrocoma boliviensis 5773.97 Abrocoma_boliviensis_ABR... 2.829928 3 Abrocoma cinerea 381391.02 Abrocoma_cinerea_ABROCOM... 2.829928 4 Abrothrix andinus 722551.83 Abrothrix_andinus_CRICET... 1.614762 5 Abrothrix hershkovitzi 1775.72 Abrothrix_hershkovitzi_C... 1.614762 6 Abrothrix illuteus 35359.55 Abrothrix_illuteus_CRICE... 1.614762 7 Abrothrix jelskii 506394.71 Abrothrix_jelskii_CRICET... 1.614762 8 Abrothrix lanosus 43016.67 Abrothrix_lanosus_CRICET... 1.614762 9 Abrothrix longipilis 423823.71 Abrothrix_longipilis_CRI... 1.614762 In\u00a0[9]: Copied! <pre># find names in tree but not in data table\nnames_in_data = set(sppdata.treename)\nnames_in_tree = set(tree.get_tip_labels())\nnames_to_keep = names_in_tree.intersection(names_in_data)\n</pre> # find names in tree but not in data table names_in_data = set(sppdata.treename) names_in_tree = set(tree.get_tip_labels()) names_to_keep = names_in_tree.intersection(names_in_data) In\u00a0[17]: Copied! <pre># only keep tree tips that are in the table\nftree = tree.mod.prune(*names_to_keep)\nprint(len(ftree), \"tips in filtered tree (ftree)\")\n</pre> # only keep tree tips that are in the table ftree = tree.mod.prune(*names_to_keep) print(len(ftree), \"tips in filtered tree (ftree)\") <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[17], line 3\n      1 # only keep tree tips that are in the table\n      2 ftree = tree.mod.prune(*names_to_keep)\n----&gt; 3 print(len(ftree), \"tips in filtered tree (ftree)\")\n\nTypeError: object of type 'ToyTree' has no len()</pre> In\u00a0[\u00a0]: Copied! <pre># transform georange into Ne values within selected range\nmax_Ne = 1000000\nmin_Ne = 1000\n\n# set Ne values in range scaled by geographic ranges\nNe = max_Ne * (sppdata.georange / sppdata.georange.max())\nNe = [max(min_Ne, i) for i in Ne]\nsppdata[\"Ne\"] = np.array(Ne, dtype=int)\n\n# show 10 random samples\nsppdata.sample(10)\n</pre> # transform georange into Ne values within selected range max_Ne = 1000000 min_Ne = 1000  # set Ne values in range scaled by geographic ranges Ne = max_Ne * (sppdata.georange / sppdata.georange.max()) Ne = [max(min_Ne, i) for i in Ne] sppdata[\"Ne\"] = np.array(Ne, dtype=int)  # show 10 random samples sppdata.sample(10) In\u00a0[\u00a0]: Copied! <pre># plot a histogram of Ne values\na, b = np.histogram(sppdata.Ne, bins=25)\ntoyplot.bars((a, b), height=300, width=400, yscale=\"log\", ylabel=\"bin count\", xlabel=\"Ne\");\n</pre> # plot a histogram of Ne values a, b = np.histogram(sppdata.Ne, bins=25) toyplot.bars((a, b), height=300, width=400, yscale=\"log\", ylabel=\"bin count\", xlabel=\"Ne\"); In\u00a0[\u00a0]: Copied! <pre># make a copy of the filtered tree\ntree_ng = ftree.copy()\n\n# dictionaries mapping names to values\ndict_ne = {sppdata.treename[i]: sppdata.Ne[i] for i in range(sppdata.shape[0])}\ndict_gt = {sppdata.treename[i]: sppdata.gentime[i] for i in range(sppdata.shape[0])}\n\n# set values on nodes of the tree for all species (tips)\ntree_ng = tree_ng.set_node_values(\"Ne\", dict_ne)\ntree_ng = tree_ng.set_node_values(\"g\", dict_gt)\n\n# estimate and set values on ancestral nodes as well.\ntree_ng = tree_ng.pcm.ancestral_state_reconstruction(\"g\")\ntree_ng = tree_ng.pcm.ancestral_state_reconstruction(\"Ne\")\n</pre> # make a copy of the filtered tree tree_ng = ftree.copy()  # dictionaries mapping names to values dict_ne = {sppdata.treename[i]: sppdata.Ne[i] for i in range(sppdata.shape[0])} dict_gt = {sppdata.treename[i]: sppdata.gentime[i] for i in range(sppdata.shape[0])}  # set values on nodes of the tree for all species (tips) tree_ng = tree_ng.set_node_values(\"Ne\", dict_ne) tree_ng = tree_ng.set_node_values(\"g\", dict_gt)  # estimate and set values on ancestral nodes as well. tree_ng = tree_ng.pcm.ancestral_state_reconstruction(\"g\") tree_ng = tree_ng.pcm.ancestral_state_reconstruction(\"Ne\") In\u00a0[\u00a0]: Copied! <pre># make a tree copy\natree = tree_ng.copy()\n\n# get ancestor of all tips that have 'Mustela' in their name\nmrca_node_idx = atree.get_mrca_idx_from_tip_labels(wildcard=\"Mustela_\")\n\n# get the TreeNode object of this subtree\nnode = atree.get_feature_dict(\"idx\")[mrca_node_idx]\n\n# create as a new Toytree\nsubtree = toytree.tree(node)\n\n# scale the tree height from millions of year to years\nsubtree = subtree.mod.node_scale_root_height(subtree.treenode.height * 1e6)\n</pre> # make a tree copy atree = tree_ng.copy()  # get ancestor of all tips that have 'Mustela' in their name mrca_node_idx = atree.get_mrca_idx_from_tip_labels(wildcard=\"Mustela_\")  # get the TreeNode object of this subtree node = atree.get_feature_dict(\"idx\")[mrca_node_idx]  # create as a new Toytree subtree = toytree.tree(node)  # scale the tree height from millions of year to years subtree = subtree.mod.node_scale_root_height(subtree.treenode.height * 1e6) In\u00a0[\u00a0]: Copied! <pre>subtree.draw(\n    ts='p',\n    edge_type='p',\n    node_sizes=10,\n    node_labels=False,\n    node_colors=[\n        colormap.colors(i, 0.1, 10) for i in subtree.get_node_values('g', 1, 1)\n    ],\n    width=400,\n    height=600,\n);\n</pre> subtree.draw(     ts='p',     edge_type='p',     node_sizes=10,     node_labels=False,     node_colors=[         colormap.colors(i, 0.1, 10) for i in subtree.get_node_values('g', 1, 1)     ],     width=400,     height=600, ); In\u00a0[\u00a0]: Copied! <pre># divide the edge lengths (in abosolute time) by the generation time\nttree = subtree.set_node_values(\n    \"dist\",\n    {i.name: i.dist / i.g for i in subtree.get_feature_dict()}\n)\n</pre> # divide the edge lengths (in abosolute time) by the generation time ttree = subtree.set_node_values(     \"dist\",     {i.name: i.dist / i.g for i in subtree.get_feature_dict()} ) In\u00a0[\u00a0]: Copied! <pre>ttree.draw(\n    ts='p',\n    edge_type='p',\n    tip_labels_align=True,\n    tip_labels=[i.rsplit(\"_\", 2)[0] for i in ttree.get_tip_labels()],\n    node_labels=False,\n    node_sizes=0,\n    width=400,\n    height=400,\n);\n</pre> ttree.draw(     ts='p',     edge_type='p',     tip_labels_align=True,     tip_labels=[i.rsplit(\"_\", 2)[0] for i in ttree.get_tip_labels()],     node_labels=False,     node_sizes=0,     width=400,     height=400, ); In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"cookbooks/cookbook-gentime-empirical/#msc-simulations-and-generation-time-variation-empirical","title":"MSC simulations and generation time variation (empirical)\u00b6","text":"<p>The purpose of this notebook is to demonstrate ipcoal simulations on a topology inferred from empirical data. We provide recommendations for how to scale units from a time-calibrated phylogeny to use in coalescent simulations, and how to incorporate biological information about species, such as generation times and population sizes, to perform more realistic simulations.</p> <p>Simulating coalescent genealogies and sequences on a parameterized species tree model using ipcoal can provide a null expectation for the amount of discordance that you expect to observe across different nodes of a species tree, and can even be used as a posterior predictive tool for phylogenetic analyses.</p>"},{"location":"cookbooks/cookbook-gentime-empirical/#mammal-phylogeny-data-set","title":"Mammal phylogeny data set\u00b6","text":"<p>In this example we use published data for mammals. We will use a time-calibrated MCC phylogeny by Upham et al. (2009) as a species tree hypothesis; we will use species geographic areas from the PanTHERIA database as a proxy for effective population sizes; and we will use generation time estimates from the Pacifici et al. (2014) data set, which imputes a lot of missing data from pantheria by using mean values among close relatives.</p>"},{"location":"cookbooks/cookbook-gentime-empirical/#filtering-and-selecting-taxa","title":"Filtering and selecting taxa\u00b6","text":"<p>We will first trim the data down to include only taxa that are shared among all three data sources and for which there is no missing biological data. This reduces the data set to 3121 taxa. The distribution of geographic range areas is in units of kilometers2 (<code>geogrange</code>) and generation times is in units of years (<code>gentime</code>).</p>"},{"location":"cookbooks/cookbook-gentime-empirical/#filter-the-tree-to-include-only-taxa-in-the-data-table","title":"Filter the tree to include only taxa in the data table\u00b6","text":""},{"location":"cookbooks/cookbook-gentime-empirical/#convert-geographic-ranges-to-ne-values","title":"Convert geographic ranges to Ne values\u00b6","text":"<p>Here we generate a range of Ne values within a selected range that are scaled by the variation in geographic range area sizes among taxa. The distribution is plotted as a histrogram on a y-axis log scale. Many taxa have small Ne, few have very large Ne.</p>"},{"location":"cookbooks/cookbook-gentime-empirical/#set-ne-and-g-values-for-tip-and-ancestral-nodes-on-the-tree-object","title":"Set Ne and g values for tip and ancestral nodes on the tree object\u00b6","text":"<p>ipcoal can accept different Ne and g values to use in simulations, and the easiest way to set variable values across different parts of the tree is to map the values to the tree object that ipcoal accepts as an argument. We only have estimates of Ne and g for species that are alive today, but it would be useful to also includes estimates for ancestral nodes in the species tree. Here we use a simple ancestral state reconstruction based on Brownian motion to infer states for ancestral nodes.</p>"},{"location":"cookbooks/cookbook-gentime-empirical/#plot-tree-with-ne-and-g-values","title":"Plot tree with Ne and g values\u00b6","text":"<p>Let\u2019s plot just a subset of taxa to start, since it will be much easier to visualize than trying to examine the entire tree. Here we select only the taxa in the genus Mustela. The tree plot shows variation in Ne using the thickness of edges, and generation times are shows by the color of nodes, blue to red, representing shorter to longer times. The <code>ts='p'</code> drawing option automatically pulls the Ne information from the nodes of the tree to draw the edge thickness.</p>"},{"location":"cookbooks/cookbook-gentime-empirical/#convert-edge-lengths-from-time-to-generations","title":"Convert edge lengths from time to generations\u00b6","text":"<p>Time in years is converted to units of generations by dividing by each edge length by the generation time for that edge, recorded as ngenerations/year. When this is done the crown root age of the Mustela tree is now at 2.4M generations from the furthest tip in the tree. This tree object (ttree) now contains information in its Ne values mapped to nodes and in its edge lengths to fully represent the data on population sizes and generation time differences among species and their ancestors. This is the tree we will use for our ipcoal simulations.</p>"}]}